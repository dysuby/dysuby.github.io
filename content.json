{"pages":[{"title":"About","text":"关于我： SYSU SE 不会不懂不学 邮箱：h_foryou@163.com github：vegchic 关于这个博客：年更，反正也没人看","link":"/about/index.html"}],"posts":[{"title":"Beier–Neely morphing algorithm","text":"Beier–Neely morphing algorithm 算法原理主要算法流程如下： 因为有是生成中间帧，所以目标图是每一张中间帧，而原图为输入图像。为避免歧义，将输入图像称为 $src$ 和 $dst$。 简单地说，对于中间帧的每一个像素 $X$ ，对于每一条特征线，计算 $X$ 在 $src$ 和 $dst$ 基于该特征线的映射，然后加权平均算出最终在两图的映射 $X’$。然后使用 Bilinear 插值求出两个 $X’$ 的像素值，再加权平均求得 $X$ 最终的像素值。 生成中间帧特征线这里根据帧数计算权重作 $src$ 和 $dst$ 特征线对的插值。设 $s$ 为特征线的起点，$e$ 为特征线的终点，则 $$ratio=i/n,i=1,\\dots,n$$ $$s’=s_{src}\\cdot(1-ratio)+s_{dst} \\cdot ratio$$ $$e’=e_{src}\\cdot(1-ratio)+e_{dst} \\cdot ratio$$ 计算 $X’$ 由上图可见，主要是通过 $X$ 在目标图中相对于特征线（向量）的位置，映射回原图对应特征线相对的位置。这个位置由 $X$ 在特征线上的投影和距离决定。 $$u=\\frac{(X-P)\\cdot(Q-P)}{||Q-P||^2}$$ $$v=\\frac{(X-P)\\cdot Perpendicular(Q-P)}{||Q-P||}$$ $$X’=P’+u\\cdot(Q’-P’)+\\frac{v\\cdot Perpendicular(Q’-P’)}{||Q’-P’||}$$ $X’$ 的加权平均通过下面的权重公式计算每一条特征线在当前 $X$ 中占的权重： $$weight=( \\frac{length^p}{a+dis})^b$$ 其中 $a,b,p$ 为参数，我取的是 $1,2,0$，即权重与特征线的长度无关。 然后加到一个总的 $xsum$ 和 $weightsum$ 上 $$xsum =xsum+ X’ \\cdot weight$$ $$weightsum=weightsum+weight$$ 当所有特征线都遍历过后，就可以求出最终的 $X’$ $$X’=xsum/weightsum$$ Bilinear这里是通过映射得到的 $X’$ 获得对应的 rgb。借用课件的图： 假设绿点为 $(x,y)$，对应的像素值为 $S(x,y)$，则有 $$S(x,y)=(1-a)\\cdot(1-b)\\cdot S(i,j)+a\\cdot(1-b)\\cdot S(i+1,j)+(1-a)\\cdot b\\cdot S(i,j+1)+a\\cdot b\\cdot S(i+1,j+1)$$ 容易看出，这样插值当 $(x,y)$ 为任意一个顶点时，像素值即是该点的值。 像素值加权平均在求得 $src$ 和 $dst$ 的像素值 $s_1,s_2$ 后，设当前帧数为 $i$，总帧数为 $n$ 。则 $X$ 的像素值为 $$s_x=s_1\\cdot (1-\\frac{i}{n})+s_2\\cdot \\frac{i}{n},i=1,\\cdots, n$$ 通过上面的算法步骤即可获得 Morphing 的中间帧。当然，在运行上面算法时还要自己标出特征线。 效果 参考DIGITAL VISUAL EFFECTS","link":"/2018/11/14/Beier–Neely morphing algorithm/"},{"title":"CFLP 两种解题算法","text":"代码和结果可以在 vegchic/CFLPsolver 上找到 Capacitated Facility Location Problems现有客人 $n$ 位，工厂 $m$ 座，每个客人都有自己的服务需求，每个工厂都能提供一定数量的服务，每个客人到每座工厂都需要一定的费用，工厂刚开始是关闭的，开工厂也要付出一定的费用。现在要求： 求能满足所有客户的需求的最小代价分配方案。 以上问题可以用数学公式表达： $$y_i=\\begin{cases}1&amp;\\text{if facility }i\\text{ is opened}\\\\ 0&amp;\\text{otherwise}\\end{cases}$$ $$x_{ij}=\\begin{cases}1&amp;\\text{if facility }i\\text{ serves customer }j\\\\ 0&amp;\\text{otherwise}\\end{cases}$$ $$v^*=\\min\\sum^m_{i=1}\\sum^n_{j=1}c_{ij}x_{ij}+\\sum^m_{i=1}f_iy_i$$ $$\\text{s.t.}\\ \\sum_n^{j=1}a_jx_{ij}\\le b_iy_i \\ \\forall i,$$ $$\\sum_{i=1}^mx_{ij}=1\\ \\forall j,$$ $$x_{ij}-y_i\\le0\\ \\forall i,j,$$ $$x_{ij}\\in{0,1}\\ \\forall i, j,$$ $$y_i\\in{0,1}\\ \\forall i,$$ 其中，$a_j$ 为第 $j$ 位顾客的需求，$b_i$ 为第 $i$ 座工厂的容量，$f_i$ 为开第 $i$ 座工厂的费用，$c_{ij}$ 为将第 $j$ 位顾客分配到 $i$ 座工厂的费用。在实际编程中，我直接将 $x_{ij}$ 简化为 ${x_j}$。 迭代贪心可以使用贪心算法求一个近似解。算法如下： 123456789for i from 0 to T /* T 为迭代次数 */ shuffle customer order for c in customer choose the closet avaliable facility f if f is closed open f update solution update solution update optimal_solution 分析可以看见，该算法并没有考虑开厂的费用，因为大部分开厂费用都比分配的费用要少。通过增加迭代打乱客户顺序，可以让解变得更好，而且写起来也比较简单，该算法优点是速度快，缺点是可能误差会比较大。经试验迭代次数 $T=10$ 最好。 代码greedy.py 结果greedy_result.csv greedy_details 模拟退火模拟退火也可以求一个近似解。通过按概率接受差解可以跳出局部最优解。算法如下： 123456789generate the init solutionoptimal = init_solutionwhile T &gt; tmin: for i from 0 to times new_solution = localsearch(solution) delta = new_solution.cost - optimal.cost if new_solution.cost &lt; optimal.cost or random() &lt; exp(-delta / T) update optimal drop T by t_rate 邻域算子 随机交换两个顾客分配到的工厂： 初始化候选表，里面包含客户两两配对的所有情况。 随机选择两个顾客。 如果交换后不能满足约束，从候选表中移除这个组合，如果候选表为空，则返回当前解，否则转到 2。 交换两个顾客分配到的工厂，更新 $x$ 和总费用。 随机将一个顾客移到另一个工厂： 初始化工厂的候选表和顾客的候选表。 随机选择一个顾客。 随机选择一个工厂。 如果顾客不能转移到该工厂，则从工厂候选表中移除该工厂，如果工厂候选表不为空，转 3，如果为空，则从客户候选表中移除该客户，如果客户候选表不为空，转 2，否则返回当前解。 将顾客转移并更新 $x$ 和总费用，如果转移后使顾客原来的工厂没有服务的顾客，则关闭该工厂并更新 $y$ 和总费用。 随机选择一个工厂，将其他工厂的顾客分配到它上直到达到其容量限制： 初始化工厂的候选表。 随机选择一个工厂。 如果工厂的剩余容量不能满足任意一位顾客（本来应该是其他工厂的顾客，这里做了简化）的需求，则从候选表中移除该工厂，如果不为空，转 2，否则返回当前解。 打乱顾客顺序。并将能放进该工厂的顾客转移到该工厂，如果转移后使原来的工厂不再服务任何顾客，则关闭工厂，更新 $x​$，$y​$，还有总费用。 分析模拟退火耗时比贪心长，但是可以找到更优解，在实验中参数取 $T=100,\\ tmin=5,\\ times=3000,\\ trate=0.95$ 代码SA.py 结果sa_result.csv sa_details 对比自己写了个 compare.py，比较了下模拟退火和贪心（将退火花费的时间和解的费用与贪心作对比）：compare.csv。从性价比来看，退火用时过长，不太划算，不过这也是因为我的写法太过耗时。","link":"/2018/12/22/CFLP 两种解题算法/"},{"title":"Canny 边缘检测","text":"计算机视觉的作业，虽然完成的不好，但是还是记录下8。 Canny 边缘检测转灰度图当拿到一张彩色图时，为了方便之后的处理，首先要进行的是灰度图的转化，这里直接使用了 BT. 709 的灰度转化公式：$$Y′ = 0.2126 R′ + 0.7152 G′ + 0.0722 B’$$ 高斯模糊既然拿到了灰度图，接下来就要进行去噪处理，不然噪点会影响后面对边缘的检测，Canny 使用的是高斯模糊，看了算法之后感觉还是很好理解的，就是通过二维的正态分布函数计算出一个滤波器，并与原图进行卷积，刚开始没接触过卷积，觉得很高大上，但在这里卷积其实就是将邻域的点加权平均而已。 大小为 $k$ 的滤波器函数：$$G(u,v)= \\frac{1}{2\\pi\\sigma^2}\\exp(-((u-k)^2-(v-k)^2)/(2\\sigma^2))$$ 卷积：$$img(x, y)=\\sum_{i=-1}^1 \\sum_{j=-1}^1 img(x-i,y-j)*G(i,j)$$，此处 $G(0,0)$ 对应 $img(x,y)$ 计算梯度在我的理解中，一个点的梯度可以告诉我们这个点的变化方向和大小，如果变化足够大，便有理由认为这个点为边缘点。这里使用的是 Sobel 算子计算梯度，其公式为： $x$ 方向上：$$G_x=\\begin{bmatrix}+1&amp;0&amp;-1\\\\ +2&amp;0&amp;-2\\\\ +1&amp;0&amp;-1\\end{bmatrix} *A$$ $y$ 方向上：$$G_y=\\begin{bmatrix}+1&amp;+2&amp;+1\\\\ 0&amp;0&amp;0\\\\ -1&amp;-2&amp;-1\\end{bmatrix} *A$$ 总的：$G=\\sqrt{G_x^2+G_y^2}$ 非极大值抑制这个部分其实我也不算太理解，但是根据网上的一些资料，我认为在上一步中有一些边缘被重复检测了，而这里则要对这些边缘进行筛选，比如说一个边缘点 $E_i=(x,y)$，现在要找的 $E_{i+1}$有好几个点都满足条件，这时就要找一个最符合条件的点。NMS 将梯度方向上的极大值点保留，而将非极大值点抑制。这里没有什么公式，只是根据梯度的方向计算出两个线性插值，以这两个插值作为比较对象进行极大值判断。这里也不好讲清楚，具体可以去看看代码。（注：梯度方向垂直于边缘方向） 权重的计算公式：$$weight=\\left\\vert \\frac{min{gradx(x, y), grady(x,y)}}{max{gradx(x, y), grady(x, y)}}\\right\\vert$$ 12if (nms(x, y) &gt; p1 &amp;&amp; nms(x, y) &gt; p2) nms(x, y) = grad(x, y);else nms(x, y) = 0; 滞后阈值滞后阈值使用高低两个阈值（高阈值记为th，低阈值记为tl）来区分边缘像素，这里直接用伪代码表示出来更直观。 1234567for point in image if point &gt; th point = EDGE else if point &lt; tl point = NOEDGE else if there is any EDGE in 8-neighbourhood // 不知道八邻域怎么说 point = EDGE 这里对强边缘点和非边缘点的处理都可以理解，而对弱边缘点的处理则有点难理解，我认为强边缘点终究不是所有的边缘点，而弱边缘点便是用来补充强边缘点的，如果一个点的八邻域内有强边缘点，则这个点就可以被认为是一个边缘点，就好像连线一样。 反思这次实验作业要求我们改写并封装代码，但是由于个人水平有限，原代码的许多地方我无法理解，所以不得不参考了网上的资料以及提供的其他原代码，虽然写出来都是 Canny 算法，但是内容已经与我需要改写的那部分原代码差之甚远，没有满足作业的要求。 在查资料和阅读原代码的过程中，我也收获了很多，例如我刚开始并不知道高斯模糊为什么叫高斯模糊，它究竟是个什么原理，但是自己写了一遍之后便发现，原来使用的是正太分布，原理也如此简单。直到现在，我感觉我对这个算法也有了一定的了解，但却也谈不上掌握，因为我并不知道 Canny 相较于其他算法有何差别。 Canny 算法在我看来并不难理解，因为它的每一步的目的都很清晰，从去噪到求梯度再到区分筛选，都有理可循，但是我可能是学识尚浅，并不能在细节上区分实现不同导致的效果好坏，看同学的实现效果似乎也与自己有些差别，深知自己需要学习的还有很多。 参考资料明明看的都是中文 wiki 却要放英文 wiki Grayscale Canny edge detector Sobel operator Gaussian blur Canny算子中的非极大值抑制（Non-Maximum Suppression）分析 以及其他一些博客。","link":"/2018/10/17/Canny 边缘检测/"},{"title":"Golang 垃圾回收机制","text":"本文简单介绍 golang 的垃圾回收（Garbage Collection） 前言垃圾回收是编程语言中提供的内存管理功能。 在 C/C++ 中，堆变量的内存是由程序员自己维护的，即如果变量不再使用，需要程序员手动释放内存，不然会发生资源浪费甚至内存泄漏。 123456789// C++ exampleint main() &#123; int *a; for (size_t i = 0; i &lt; 1000000; ++i) &#123; a = new int[1000]; // delete[] a; doesn't free memory, result in crashed &#125; return 0;&#125; 为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 —— 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由 虚拟机（virtual machine）或 运行时（runtime） 来自动进行管理。而这种对不再使用的内存资源进行自动回收的功能就被称为垃圾回收。 垃圾回收算法这里只介绍常用的 引用计数，以及 golang 使用到的 标记-清楚，三色标记法 引用计数（Reference counting）引用计数的思想很简单，就是当有其他变量引用该对象时计数器就加一，当引用该对象的变量不再引用或是被回收时计数器就减一，当计数器为 0 时对象便会被回收。 优点： 方法简单，回收速度快 缺点： 无法解决循环引用问题 花费额外空间 更新计数器影响性能 标记 - 清除（Mark and Sweep） 标记从根变量开始迭代遍历所有被引用的对象，对能够通过应用遍历访问到的对象都标记为“被引用”； 标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。 用图表示如下： 优点： 解决了引用计数的问题 缺点： 垃圾回收时会 stop the world，存在性能问题 后续出现了很多 mark&amp;sweep 算法的变种（如三色标记法）优化了这个问题。 三色标记算法（Tricolor Mark-and-sweep Algorithm）三色标记法是对 标记-清除 的改进，在 mark 时，不再简单标记，而是： 将所有对象标为 白色 将可达到的对象标记为 灰色 将 灰色 对象的引用对象标为新的灰色，并将当前对象标为黑色 重复步骤 3，直至不存在灰色对象 清除的时候再将白色对象回收。 用图表示如下： 写屏障（Write Barrier）为了解决 GC 的同时用户修改了引用关系引入的拦截机制，会在 GC 运行时监视内存修改，并对对象重新标记。 假设有两种情况： 产生了新对象：GC 会把所有新对象标记为 灰色，避免被 sweep 引用了 白色 对象：重新标记为灰色 Go GC 上图便是 Golang 的 GC 流程，可以看到，STW 只有 GC 开始时和 Re-scan（更新写屏障监视到的修改） 时出现，优化了性能。 变化过程 v1.1 STW v1.3 Mark STW, Sweep 并行 v1.5 三色标记法 v1.8 hybrid write barrier（Yuasa-style deletion write barrier [Yuasa ‘90] 和 Dijkstra-style insertion write barrier [Dijkstra ‘78]） ReferenceGO GC 垃圾回收机制 图解Golang的GC算法 Golang 垃圾回收剖析","link":"/2019/06/20/Golang 垃圾回收机制/"},{"title":"LaTeX简单使用","text":"前言 因为离散要求写一篇算法的小文章，实在无法忍受word的数学公式输入之后，我自（ctrl）学（c）了一下LaTeX的写法，这里简单介绍我写文章时用到的代码，时隔多日，若有偏差欢迎指出 中文LaTeX 百度上输出中文的方法各种各样，在尝试n多种方法无果后（CJK什么的），使用了XeLaTeX，只需使用如下文档类型，中括号内为可选参数，UTF8表示使用utf8编码，花括号内为文档类型，ctexart表示其文档类型为中文article 1\\documentclass[UTF8]&#123;ctexart&#125; 正文区形如\\begin{环境名}...\\end{环境名}称为环境，而\\begin{document}...\\end{document}则是正文区，里面的内容就是文章的内容，而这之前的部分则是用来导入各种宏包 标题摘要下面代码较为易懂，\\maketitle也即打印标题1234\\title&#123;Notes On LaTeX Typesetting&#125;\\author&#123;Some One&#125;\\date&#123;November 13, 2011&#125;\\maketitle 当然还可以写摘要 123\\begin&#123;abstract&#125;some abstract...\\end&#123;abstract&#125; 章节目录代码如下，其中\\chapter在article中不能使用 1234567\\part&#123;部分标题&#125;\\chapter&#123;章标题&#125;这一章我们介绍这些内容。\\section&#123;节标题&#125;这一节我们介绍这些内容。\\subsection&#123;小节标题&#125;这一小节我们介绍这些内容。\\subsubsection&#123;子节标题&#125;这一子节我们介绍这些内容。\\paragraph&#123;段标题&#125;这一段我们介绍这些内容。\\subparagraph&#123;小段标题&#125;这一小段我们介绍这些内容。 使用\\tableofcontents 可以生成目录，而输入形如 1\\renewcommand\\thesection&#123;§\\arabic&#123;section&#125;&#125; 则可以自定义某一类章节标题的格式，在此不作示范 列表环境这里列举三种列表，分别为无序列表，有序列表，描述列表 123456789101112131415\\begin&#123;itemize&#125; %无序列表\\item 无编号的列表\\item 带编号的列表\\item 带标签的列表\\end&#123;itemize&#125;\\begin&#123;enumerate&#125; %有序列表\\item 无编号的列表\\item 带编号的列表\\item 带标签的列表\\end&#123;enumerate&#125;\\begin&#123;description&#125; %描述列表\\item[无序列表] 无编号的列表。%中括号内为描述内容（相当于一种“序号”）\\item[有序列表] 带编号的列表。\\item[描述列表] 带标签的列表。\\end&#123;description&#125; 插入图片插入已有图片需要导入宏包graphicx，即\\usepackage{graphicx}，使用如下 12345678910111213\\includegraphics[选项]&#123;图形文件&#125; %与文字并行的图片%将图片单独居中插入\\begin&#123;center&#125;\\includegraphics[选项]&#123;图形文件&#125;\\end&#123;center&#125;%插入浮动图片\\begin&#123;figure&#125;[htbp!]\\centering\\includegraphics[选项]&#123;图形文件&#125;\\caption&#123;图片&#125; %可以在图片下方加标注并自动编号\\end&#123;figure&#125; 输入数学公式此处即makedown写法即可，$a=1$为行内公式，$$a=1$$为块级公式，具体写法参考LaTeX/Mathematics 插入伪代码这里需要导入宏包 1234\\usepackage&#123;caption&#125;\\usepackage&#123;algorithm&#125;\\usepackage&#123;algorithmicx&#125; \\usepackage&#123;algpseudocode&#125; 插入时则 1234567891011121314151617\\begin&#123;algorithm&#125; \\caption&#123;算法名字&#125;\\begin&#123;algorithmic&#125;\\Require 输入\\Ensure 输出\\end&#123;algorithmic&#125;\\State ...\\For&#123;...&#125; \\State ...\\EndFor\\If...\\EndIf\\While...\\EndWhile\\end&#123;algorithm&#125; 其中还可以对格式进行定制 123\\floatname&#123;algorithm&#125;&#123;算法&#125; \\renewcommand&#123;\\algorithmicrequire&#125;&#123;\\textbf&#123;输入:&#125;&#125; \\renewcommand&#123;\\algorithmicensure&#125;&#123;\\textbf&#123;输出:&#125;&#125; 插入代码这里需要导入宏包 1\\usepackage&#123;listings&#125; 还可以对代码进行定制 12345678910\\usepackage&#123;xcolor&#125;\\lstset&#123; frame=none, % 不显示背景边框 backgroundcolor=\\color[RGB]&#123;245,245,244&#125;, % 设定背景颜色 keywordstyle=\\color[RGB]&#123;116,0,0&#125;, % 设定关键字颜色 commentstyle=\\it\\color[RGB]&#123;0,96,96&#125;, % 设置代码注释的格式 stringstyle=\\rmfamily\\slshape\\color[RGB]&#123;255,153,18&#125;, % 设置字符串格式 showstringspaces=false, % 不显示字符串中的空格 language=c++, % 设置语言&#125; 插入代码时使用lstlisting环境即可 12345678910\\begin&#123;lstlisting&#125;#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"hello\" &lt;&lt; endl; return 0;&#125;\\end&#123;lstlisting&#125; 参考文献12345\\begin&#123;thebibliography&#125;&#123;123456&#125;\\bibitem[Knuth1]&#123;DK1&#125; D. Knuth, T.A.O.C.P. , Vol. 1, Addison-Wesley, 1997.\\bibitem[Knuth2]&#123;DK2&#125; D. Knuth, T.A.O.C.P. , Vol. 2, Addison-Wesley, 1997.\\bibitem[Knuth3]&#123;DK3&#125; D. Knuth, T.A.O.C.P. , Vol. 3, Addison-Wesley, 1998.\\end&#123;thebibliography&#125; 中括号内为文献记号，花括号内为引用名称，至于那个123456表示我也看不懂。 字体环境123\\textrm&#123;Roman Family&#125;\\textsf&#123;Sans Serif Family&#125;\\texttt&#123;Typewriter Family&#125; 花括号内为字体内容 感谢本文内容及示例参考LaTeX 排版学习笔记以及 LaTeX实战经验：如何插入程序代码，写文章时也参考诸多博客，感谢这些博客","link":"/2017/10/05/LaTeX简单使用/"},{"title":"【week10】583. Delete Operation for Two Strings 解题报告","text":"583. Delete Operation for Two Strings 题目iven two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1: 123Input: &quot;sea&quot;, &quot;eat&quot;Output: 2Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;. Note: The length of given words won’t exceed 500. Characters in given words can only be lower-case letters. 解题报告题目很简单，给定两个字符串，可以删除其中任意 $n$ 个字符，求使得两个字符串相同的最小 $n$。 这题和编辑距离差不多，只是可以做的操作变了，可以定义子问题为：$dp[i][j]$ 等于使得 $word1(1,i)=word2(1,j)$ 相等的最小 $n$。 显然要使 $word1(1,i)=word2(1,j)$，可以有三种途径： 先让 $word1(1,i-1)=word2(1,j)$，再删除 $word1[i]$。 先让 $word1(1,i)=word2(1,j-1)$，再删除 $word[j]$。 先让 $word1(1,i-1)=word2(1,j-1)$，如果 $word1[i]\\ne word2[j]$，就把 $word1[i]$ 和 $word2[j]$ 都删掉。 显然，$dp[i][j]$ 为上述三种途径中花费最小的那个。另外，当其中一个字符串为空串时要让另一个长度为 $k$ 的字符串与之相等需要的最小 $n$ 即 $k$（删除另一个字符串的所有字符）。 得到了状态转移方程后就很简单了。 Solution123456789101112class Solution &#123;public: int minDistance(string word1, string word2) &#123; vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1, 0)); for (int i = 0; i &lt;= word1.size(); ++i) dp[i][0] = i; for (int j = 0; j &lt;= word2.size(); ++j) dp[0][j] = j; for (int i = 1; i &lt;= word1.size(); ++i) for (int j = 1; j &lt;= word2.size(); ++j) dp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + (word1[i - 1] == word2[j - 1] ? 0 : 2)); return dp.back().back(); &#125;&#125;;","link":"/2018/11/05/【week10】583. Delete Operation for Two Strings 解题报告/"},{"title":"【week11】456. 132 Pattern 解题报告","text":"456. 132 Pattern 题目Given a sequence of n integers $a_1, a_2, \\dots, a_n$, a 132 pattern is a subsequence $a_i,a_j,a_k$ such that $i&lt;j&lt;k$ and $a_i&lt;a_k&lt;a_j$. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000. Example 1: 12345Input: [1, 2, 3, 4]Output: FalseExplanation: There is no 132 pattern in the sequence. Example 2: 12345Input: [3, 1, 4, 2]Output: TrueExplanation: There is a 132 pattern in the sequence: [1, 4, 2]. Example 3: 12345Input: [-1, 3, 2, 0]Output: TrueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. 解题报告题意很简单，只要判断数组内存不存在满足 132 范式的子序列即可。 刚开始看见这题还以为必须要子数组，天真的以为很简单。但是做了之后才发现并不容易，题目提示要使用栈，我也往这个方向上靠，尝试了许多种算法，虽然都没过，但是也摸索出了一点准则：假设存在这样的子序列为 s1 &lt; s3 &lt; s2，(s2, s3) 必须尽可能地大，这样 s1 的选择空间才大。 故而，这个问题可以拆成两部分，对于某对 (s2,s3)，查看是否有满足约束的 s1。既然是先找后面的，那不如倒着遍历数组。 现在主要的问题是如何找尽可能大的 (s2,s3)。更准确的说，对于固定的 (s2,s3)，其实只要找到 s1 &lt; s3 即可，不需要理会 s2 是不是尽可能的大。既然如此，我们在遍历数组时，如果当前 nums[i] 不能作为 s1（即 nums[i] &gt; s3 ），则只要判断 nums[i] 能不能和之前的元素构成合法的数对即可（作为 s2 ），并把所有可能合法的数对中最大的 s3 保存下来即可。 虽然主要思路出来了，但是实现还是有点巧妙。实现时把数压进栈中，当出现更大的数（s2）时，就把小于该数的元素弹出，然后再把这个 s2 压入栈中，这样栈将保持正金字塔形，所以刚才最后弹出的必然是所有弹出元素中最大的那个（s3）。 证明：假设 nums[i+1] 作为 s2 时最大的 s3 为 j，则当遍历到 nums[i] 时，栈的内部应为 [...,nums[i+1]]，因为 j 小于 nums[i+1]，所以如果此时 nums[i] &gt; nums[i+1]，则 s3 至少可以更新变大为 nums[i+1]，符合总结出的准则，如果 nums[i] &lt; nums[i+1]，则说明 nums[i] 不能作为 s2，因为不存在小于它的 s3。 Solution1234567891011121314151617class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return false; stack&lt;int&gt; sk; int j = INT_MIN; for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; if (nums[i] &lt; j) return true; while (sk.size() &amp;&amp; sk.top() &lt; nums[i]) &#123; j = sk.top(); sk.pop(); &#125; sk.push(nums[i]); &#125; return false; &#125;&#125;;","link":"/2018/11/12/【week11】456. 132 Pattern 解题报告/"},{"title":"【week12】452. Minimum Number of Arrows to Burst Balloons 解题报告","text":"452. Minimum Number of Arrows to Burst Balloons 题目There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most $10^4$ balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with $x_{start}$ and $x_{end}$ bursts by an arrow shot at x if $x_{start} \\le x \\le x_{end}$. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example: 12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 解题报告题意很简单，找出能落在所有区间 [start, end] 的数字集合的最小大小。 见到这道题第一反应就是先把最简单的情况排除掉，就是当区间数 &lt;= 1 时，只要返回区间数就好了。 然后自然就要先做排序，我刚开始的 key 是 start。看到题目的 tag 是贪心，自然就往简单的解法上靠。 第一次的解法是判断当前区间与前一个有没有重叠，如果没有就让 ans 加一，但是这有个问题，如果一个区间头尾都与相邻区间重叠的话就会出问题了。 然后我的第二种解法是，记下集合里最后一个数字，如果 last &lt; start，就把这个数字更新为当前区间的 end，同时 ans 加一。但是这又有一个问题，如果上一个区间包含当前区间的话，且最后一个数字就是上一个区间的 end 时，就会导致重复。 既然现在问题是当前 end 可能小于上一个 end，那我按 end 排序不就好了吗？把 key 一改，果然 a 掉。 那么问题来了，为什么可以这么做呢？ 首先按照 end 排序，每次只选择 end 为集合元素可以理解为尽量靠近下一个区间，这样落在下一个区间的可能性也会更大，但如果这样都不能命中下一个区间的话，那说明当前集合不能命中下一个区间，只能为下一个区间额外添加一个元素。这也是这个解法的 “贪心” 之处。 last 为什么只需要大于 start 呢？因为如果 last &gt; end ，就说明当前区间 end &gt; prev_end ，这是不可能的。 Solution123456789101112131415161718class Solution &#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if (points.size() &lt; 2) &#123; return points.size(); &#125; sort(points.begin(), points.end(), [](const pair&lt;int, int&gt; &amp;p1, const pair&lt;int, int&gt; &amp;p2) &#123; return p1.second &lt; p2.second; &#125;); int arrow = 0, x = INT_MIN; for (int i = 0; i &lt; points.size(); ++i) &#123; if (points[i].first &lt;= x) continue; ++arrow; x = points[i].second; &#125; return arrow; &#125;&#125;;","link":"/2018/11/19/【week12】452. Minimum Number of Arrows to Burst Balloons 解题报告/"},{"title":"【week13】792. Number of Matching Subsequences 解题报告","text":"792. Number of Matching Subsequences 题目Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. 123456Example :Input: S = &quot;abcde&quot;words = [&quot;a&quot;, &quot;bb&quot;, &quot;acd&quot;, &quot;ace&quot;]Output: 3Explanation: There are three words in words that are a subsequence of S: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;. Note: All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50]. 解题报告题意很简单，给定一个源字符串 S 和一组字符串 words，问 words 内有多少是 S 的子序列。 如果用暴力解的话这题很简单，但是时间代价是 $O(NM)$，$N$ 为 S的长度，$M$ 为 words 的长度。所以需要找更高效的算法。 12345678910111213141516171819// Bruth-Forceclass Solution &#123;public: int numMatchingSubseq(string S, vector&lt;string&gt;&amp; words) &#123; vector&lt;int&gt; indices(words.size(), 0); int ans = 0; for (auto &amp;ch: S) &#123; for (int i = 0; i &lt; words.size(); ++i) &#123; if (indices[i] != -1 &amp;&amp; ch == words[i][indices[i]]) ++indices[i]; if (indices[i] == words[i].size()) &#123; ++ans; indices[i] = -1; &#125; &#125; &#125; return ans; &#125;&#125;; 从暴力解法里可以看到，每次都会在一些不匹配的字符串上浪费时间。那可不可以每个字符只匹配那些可以匹配的字符串呢？ 新的算法将每个 word 放在不同的队列里，这些队列以开头字母区分，那么假设现在 S 遍历到 c，我只需要将 queue[c] 中的每个 word 匹配并放进新的队列即可。这便可以省去寻找可以匹配的 word 的时间。 新的时间代价有点难表示，最坏的情况下为 $O(MN)$ ，即所有 word 都与 S 相同，最好时为 $O(N)$，即没有一个 word 可以匹配 S。可以通用地表示为 $O(\\max{\\sum len(subseq),N})$。其中 $subseq$ 为完全匹配或部分匹配的子序列。 Solution12345678910111213141516class Solution &#123;public: int numMatchingSubseq(string S, vector&lt;string&gt;&amp; words) &#123; vector&lt;const char*&gt; pointers[255]; for (auto &amp;w: words) &#123; pointers[w[0]].push_back(w.c_str()); &#125; for (auto &amp;c: S) &#123; auto tmp = pointers[c]; pointers[c].clear(); for (auto w: tmp) pointers[w[1]].push_back(w + 1); &#125; return pointers[0].size(); &#125;&#125;;","link":"/2018/12/02/【week13】792. Number of Matching Subsequences 解题报告/"},{"title":"【week14】397. Integer Replacement 解题报告","text":"397. Integer Replacement 题目Given a positive integer n and you can do operations as follow: If n is even, replace n with *n*/2. If n is odd, you can replace n with either *n* + 1 or *n* - 1. What is the minimum number of replacements needed for n to become 1? Example 1: 12345678Input:8Output:3Explanation:8 -&gt; 4 -&gt; 2 -&gt; 1 Example 2: 12345678910Input:7Output:4Explanation:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1or7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 解题报告题意很简单，给定一个整数 $K$ ，定义两种操作：奇数时 $K=K+1$ 或 $K=K-1$，偶数时$K=K/2$，问要多少次操作才能让 $K=1$ 成立。 刚看到这题时，我第一反应是用动规，因为状态转移方程很容易就能想出来： $$DP[i]=\\begin{cases}DP[i/2]+1, &amp; \\text{if }n\\text{ is even} \\\\min(DP[i+1],DP[i-1])+1, &amp; \\text{if }n\\text{ is odd} \\end{cases}$$ 也很容易写出来了： 1234567891011121314// DP: Memory Limit Exceededclass Solution &#123;public: int integerReplacement(int n) &#123; if (n &lt;= 2) return n - 1; vector&lt;int&gt; dp(n + 2); for (int i = 3; i &lt; n + 1; i += 2) &#123; dp[i - 1] = dp[(i - 1) / 2] + 1; dp[i + 1] = dp[(i + 1) / 2] + 1; dp[i] = min(dp[i - 1], dp[i + 1]) + 1; &#125; return dp[n]; &#125;&#125;; 可见，当 test case 为大整数时，会超出内存限制，这相当于不能使用任何数组。只能另寻他路。 然后我又想到，是否可以用贪心的思想，当 $K$ 为偶数时，操作必然是除 2，那么对于每一个操作中间产生的偶数，都可以直接把它不断除二知道它为奇数为止，再加上其操作次数。假设每一个偶数 $K$ 最后变成的奇数为 $toOdd(K)$，那对于一个奇数 $K$，如果 $toOdd(K+1)&lt;toOdd(K-1)$，则直接采用操作 $K=K+1$，具体的数学原理我也说不清，只能说当此时 $toOdd(K-1)$ 要达到 $toOdd(K+1)$ 附近必然需要更多操作。 确定这一算法之后代码也很快可以写出来： 123456789101112131415161718192021222324252627282930// Time Limit Exceededclass Solution &#123;public: int getEvenTime(int &amp;k) &#123; // 算出除2的次数顺便算出 toOdd(k) int ret = 0; while (!(k &amp; 1)) &#123; k /= 2; ++ret; &#125; return ret; &#125; int integerReplacement(int n) &#123; int plus, sub, pt, st; int even = getEvenTime(n); while (n != 1) &#123; plus = n + 1; sub = n - 1; pt = getEvenTime(plus); st = getEvenTime(sub); if (plus &lt; sub) &#123; n = plus; even += pt + 1; &#125; else &#123; n = sub; even += st + 1; &#125; &#125; return even; &#125;&#125;; 然而这次超时了，审视自己的算法，每次都要去算两次 $toOdd$，但是其中一次其实没有意义，这浪费了大量的时间，是否可以只算一次？ 因为两个数只差了 2 ，所以比较两个 $toOdd$，实际上是比较谁更能除 2，在二进制数中比较的就是谁低位的 0 更多，这让我想起了之前看过的树状数组中的 lowbit ，这是求一个二进制数最后一个 1 的位置的操作，可以表示为 x &amp; -x。那我不就可以根据这个求出谁更能除 2 吗？ 于是便有了最终的答案，其中需要注意的是，当 $K$ 为 3 时，其前后恰好是 2 和 4，这时这个判断条件会失效，要额外判断一下。 Solution1234567891011121314151617181920class Solution &#123;public: int integerReplacement(int n) &#123; if (n == INT_MAX) return 32; // 溢出 int ans = 0; while (n != 1) &#123; // toOdd while (!(n &amp; 1)) &#123; ++ans; n &gt;&gt;= 1; &#125; if (n &lt;= 3) return ans + n - 1; // 临界条件 if (((n + 1) &amp; -(n + 1)) &lt; ((n - 1) &amp; -(n - 1))) --n; else ++n; ++ans; &#125; return ans; &#125;&#125;;","link":"/2018/12/07/【week14】397. Integer Replacement 解题报告/"},{"title":"【week15】820. Short Encoding of Words 解题报告","text":"820. Short Encoding of Words 题目Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;], we can write it as S = &quot;time#bell#&quot; and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a &quot;#&quot; character. What is the length of the shortest reference string S possible that encodes the given words? Example: 123Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]Output: 10Explanation: S = &quot;time#bell#&quot; and indexes = [0, 2, 5]. Note: 1 &lt;= words.length &lt;= 2000. 1 &lt;= words[i].length &lt;= 7. Each word has only lowercase letters. 解题报告题意不太简单，绕了一下。 很容易想到，如果一个单词 $words[i]$ 可以被 $words[j]$ 代替，那么它必然是 $words[j]$ 的子串。而且是从尾部开始的子串。 问题是怎么检测出两个单词间的关系，暴力一点可以直接两层循环 $O(N^2)$ ，但是这样太慢了，需要找一种方法快速剔除子串。这样我想到了哈希，首先可以把所有单词放进一个 unordered_set 里，然后把剔除每个 $word$ 的 每个子串，这看起来很麻烦，但其实并不会花费很多时间，因为 unorder_set 的操作是 $O(1)$ 的，而每个单词的长度不超过 7，几乎可以忽略不计，所以基本上整个剔除操作几乎是 $O(N)$ 的。而后面的计算答案就不用说了，时间代价也是 $O(N)$，所以总的时间代价是 $O(N)$ 的。 当然，这么做也不是最好的，还有一种方法是建立 Trie 树，但是这个我不会。。看评论区还有一种巧妙的算法是反转+排序：反转每个字符串，然后排序，这样只需检查 $sorted[i]$ 和 $sorted[i+1]$ 的关系即可，感觉也很独特。 Solution12345678910111213class Solution &#123;public: int minimumLengthEncoding(vector&lt;string&gt;&amp; words) &#123; unordered_set&lt;string&gt; us(words.begin(), words.end()); for (auto w: words) for (int i = 1; i &lt; w.size(); ++i) us.erase(w.substr(i)); int ret = 0; for (auto s: us) ret += s.size() + 1; return ret; &#125;&#125;;","link":"/2018/12/11/【week15】820. Short Encoding of Words 解题报告/"},{"title":"【week1】55. Jump Game 解题报告","text":"55. Jump Game 题目Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 解题报告题意很简单，从数组的开始跳，判断能否跳到终点，数组元素为该处能跳的最远距离。 从题目的 tag 可知可以用贪心解，容易想到，每次都要跳最远。所以每一次都从起点 $begin$ 能跳到的最远的地方 $begin + len$ 开始往前找能跳的最远的落点。 a了之后看了看别人的解法发现自己的还是过于冗余，有重复计算。实际上从数组开始一步一步遍历，每轮都判断该落点能否跳得更远，如果该落点大于此时能跳到的最远落点时，则跳不到终点，最终时间代价只需要 $O(n)$。 Solution123456789101112131415161718192021222324252627// My Solutionclass Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int begin = 0, next = nums[0]; while (nums[begin] &amp;&amp; next &lt; nums.size() - 1) &#123; for (int i = next; i != begin; --i) next = nums[i] + i &gt; nums[next] + next ? i : next; begin = next; next = begin + nums[begin]; &#125; return next &gt;= nums.size() - 1; &#125;&#125;;// Others' Solutionclass Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int maxind = 0; for(int i=0;i&lt;nums.size();i++)&#123; if(maxind&lt;i) return false; if(i+nums[i]&gt;maxind) maxind = nums[i]+i; &#125; return true; &#125;&#125;;","link":"/2018/09/07/【week1】55. Jump Game 解题报告/"},{"title":"【week2】901. Online Stock Span 解题报告","text":"901. Online Stock Span 题目Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock’s price for the current day. The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6]. Example 1: 1234567891011121314Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]Output: [null,1,1,1,2,1,4,6]Explanation: First, S = StockSpanner() is initialized. Then:S.next(100) is called and returns 1,S.next(80) is called and returns 1,S.next(60) is called and returns 1,S.next(70) is called and returns 2,S.next(60) is called and returns 1,S.next(75) is called and returns 4,S.next(85) is called and returns 6.Note that (for example) S.next(75) returned 4, because the last 4 prices(including today&apos;s price of 75) were less than or equal to today&apos;s price. Note: Calls to StockSpanner.next(int price) will have 1 &lt;= price &lt;= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages. 解题报告题意很简单，有一个序列，每次往里面插入 price 时都要往前看有多少个不大于它的数（包括本身），称为 span。 最简单是维护一个 vector，每次查询都往前搜索，本来也想这么做的，但是看评论说有 $O(1)$ 的方法，惊为天人，于是苦思冥想。 这道题明显是需要某种数据结构来配合，再看每次查询的操作，与栈有异曲同工之妙，如果用栈的话，那每次查询必然是将不大于 price 的元素弹出，这样就必须保存状态，则容易想到可以用 pair&lt;int, int&gt; 保存每个 price 的 span，这样如果当前 price 大于等于栈顶的 price ，那也必然大于等于栈顶 price 的 span 包含的 price （可能讲的不太好）。 换个说法，相当于将所有 price 分成一段一段，每一段的最大值留在栈中并记录该段的 price 数目，每次插入时相当于把小段合并成大段再压入栈中。 然而刚开始想到时并不觉得是 $O(1)$ ，实在想不到更好的办法，a了之后再去看那个评论发现和我做法一样。。 Solution12345678910111213141516171819202122232425class StockSpanner &#123;public: StockSpanner() &#123; &#125; int next(int price) &#123; int ans = 1; while (!stock.empty() &amp;&amp; stock.top().first &lt;= price) &#123; auto top = stock.top(); ans += top.second; stock.pop(); &#125; stock.push(make_pair(price, ans)); return ans; &#125; private: stack&lt;pair&lt;int, int&gt;&gt; stock;&#125;;/** * Your StockSpanner object will be instantiated and called as such: * StockSpanner obj = new StockSpanner(); * int param_1 = obj.next(price); */","link":"/2018/09/10/【week2】901. Online Stock Span 解题报告/"},{"title":"【week3】646. Maximum Length of Pair Chain 解题报告","text":"646. Maximum Length of Pair Chain 题目You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. Now, we define a pair (c, d) can follow another pair (a, b) if and only if b &lt; c. Chain of pairs can be formed in this fashion. Given a set of pairs, find the length longest chain which can be formed. You needn’t use up all the given pairs. You can select pairs in any order. Example 1: 123Input: [[1,2], [2,3], [3,4]]Output: 2Explanation: The longest chain is [1,2] -&gt; [3,4] Note: The number of given pairs will be in the range [1, 1000]. 解题报告题意很简单，若 b &lt; c，则可以将 (a, b) 和 (c, d) 连起来，求能连成的长链最长长度。 可以想到，首先要把传入的 pairs 进行排序方便后续的处理，因为题目用到了 pair[1]，所以以这个为基准从小到大排序。 接链子的最关键之处是每次都选尾尽量小的，而刚开始排序便提供了便利。只要把 pairs 遍历一遍，能接的接上，并记录下链尾的值，再去找下一段就可以找到最长的链子长度。算法的时间复杂度是 $O(nlogn)$，主要是排序花费。 为什么要选尽量小的？ 显然，如果大的能接上，那么小的也肯定能接上，而小的能接更多的链子。也因此要选择最小的头作为开始。所以要选尽量小的。 Solution123456789101112131415class Solution &#123;public: int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) &#123; auto cmp = [](const vector&lt;int&gt; &amp;l, const vector&lt;int&gt; &amp;r) &#123; return l[1] &lt; r[1]; &#125;; sort(pairs.begin(), pairs.end(), cmp); int res = 0; for (int i = 0, j = 0; i &lt; pairs.size(); ++i) &#123; if (i == 0 || pairs[j][1] &lt; pairs[i][0]) &#123; ++res; j = i; &#125; &#125; return res; &#125;&#125;;","link":"/2018/09/20/【week3】646. Maximum Length of Pair Chain 解题报告/"},{"title":"【week4】79. Word Search 解题报告","text":"79. Word Search 题目Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 解题报告题意大概是在一个矩阵中判断是否存在一条路恰好满足给定字符串。 本来刚开始以为可以用 DP 做，但是无奈水平有限，写不出来。于是乖乖用回溯做。除了一些小 bug 外，主要还是要注意一条路上走过的元素要做标记，并在递归出来时把标记去掉，避免下一条路卡在这里。 算法复杂度是 $O(2^n)$，本来以为挺慢的，没想到跑出来还打败了 99% 的提交。 Solution1234567891011121314151617181920212223class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; for (int i = 0; i &lt; board.size(); ++i) for (int j = 0; j &lt; board[0].size(); ++j) if (board[i][j] == word[0] &amp;&amp; dfs(board, word, 0, i, j)) return true; return false; &#125; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int index, int row, int col) &#123; if (row * col &lt; 0 || row &gt;= board.size() || col &gt;= board[0].size()) return false; if (index == word.size() - 1) return board[row][col] == word[index]; else if (board[row][col] == word[index]) &#123; board[row][col] = 0; if (dfs(board, word, index + 1, row + 1, col) || dfs(board, word, index + 1, row, col + 1) || dfs(board, word, index + 1, row - 1, col) || dfs(board, word, index + 1, row, col - 1)) return true; board[row][col] = word[index]; &#125; return false; &#125;&#125;;","link":"/2018/09/25/【week4】79. Word Search 解题报告/"},{"title":"【week5】49. Group Anagrams","text":"49. Group Anagrams 题目Given an array of strings, group anagrams together. Example: 1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase. The order of your output does not matter. 解题报告题意很简单，就是将易位之后可以互相转化的字符串分成各自的一堆。 刚开始想到的是用一个 int 作为哈希表，对一个字符串的每个字符进行 bit &amp;= (1 &lt;&lt; (c - &#39;a&#39;)) 的哈希，然后再放入 map&lt;int, vector&lt;string&gt;&gt; 里，但是还没写完就想起字母可以重复，所以要重新想。 既然刚开始已经用了哈希，那接下来自然也在想如何让同类字符串具有一样的哈希值，灵光一闪想到了质数分解（可能是之前在知乎看过这种哈希法），直觉告诉我，一个数的质数分解是唯一的，所以我省略了求证的过程。 首先将 26 个质数写出，然后通过依然是遍历每个字母，但是这次进行的是 bit *= pn[c - &#39;a&#39;] ，然后放入 map 中。果不其然 a 掉了，打败了 97.6% 的提交。 算法复杂度为 $O(M*N)$. a 了之后查了下果真有这个定理。 唯一分解性定理：每个大于1的自然数或者本身就是质数或者可写为质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。 Solution123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; map&lt;int, vector&lt;string&gt;&gt; mp; for (auto &amp;s: strs) &#123; int bit = 1; // 这道题的测例没有溢出 for (auto &amp;c: s) bit *= pn[c - 'a']; mp[bit].push_back(s); &#125; vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;entry: mp) ans.push_back(entry.second); return ans; &#125; int pn[26]&#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101&#125;;&#125;;","link":"/2018/10/02/【week5】49. Group Anagrams 解题报告/"},{"title":"【week6】322. Coin Change","text":"322. Coin Change 题目You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: 123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: 12Input: coins = [2], amount = 3Output: -1 Note:You may assume that you have an infinite number of each kind of coin. 解题报告题意很简单，就是给定硬币面值，求出能凑出目标数目的最小硬币数目，如果不能，则返回 -1。 显然不能用贪心做，看上去就像是动规的题，所以我刚开始就往上面考虑。虽然这么说，但是在动规时我还是无意间用了贪心的思想，刚开始写的是，dp[i] 表示凑出 i 元需要的最小数目，然后我每次都找出最大的可以用的硬币，求出使得 dp[i - maxAvailable * n] + n 最小的 n，然而无奈 WA。想了想这种算法有极大的 bug，如果 i 不是 maxAvailable 的倍数，那最后答案便是 -1，而且根本无需找那个最小的 n，n 即是 1。 想了很久没想出来，看了评论区的答案分享我才知道自己走错了路，思想刚开始是对的，的确要搞一个 dp[i]，但是在遍历时是对每个面值都要进行比较，选出最小的那种方案才对。这个答案还是很好理解的，只是我思考的方向不对，进入了思维的盲区。 Solution12345678910111213class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; if (coins.empty()) return -1; vector&lt;int&gt; dp(amount + 1, amount + 1); dp[0] = 0; for (int i = 1; i &lt;= amount; ++i) for (int j = 0; j &lt; coins.size(); ++j) if (coins[j] &lt;= i) dp[i] = min(dp[i], dp[i - coins[j]] + 1); return dp[amount] &lt;= amount ? dp[amount] : -1; &#125;&#125;;","link":"/2018/10/13/【week6】322. Coin Change 解题报告/"},{"title":"【week7】11. Container With Most Water","text":"11. Container With Most Water 题目Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 解题报告题意很简单，看图就可以猜出大概是要找出黑柱能装下的最大容量。 题目提示是使用双指针，我就先搞了个 begin，end作为两个黑柱，刚开始是想着两个指针同时从头开始遍历，begin 只有在 $height[end] &gt; height[begin]$ 时才更新，而 end 每次迭代都 +1，但是发现光是题图就不能得出答案。 于是想着既然同一方向不行，那就两个指针相向而行。同时我确认了一个原则：尽可能保留高的柱。刚开始我写的是：每次迭代都让下一位置较大的指针移动，即 12if (height[end - 1] &gt; height[begin - 1]) --end; else ++begin; 发现还是 a 不掉，于是想到，既然我要保留高的柱，我为什么要比较下一个柱子，我应该直接比较当前柱子呀。试了一下，a 掉了。 为什么是这样做呢 我认为 begin，end 始终在靠近对方，而当柱子高度相同时，距离越近，最大容量显然越小，所以应该尽可能保留“远处”的高柱子。 当然，其实当一个指针 i 不动时，我们是在找以 height[i] 为两个柱子其中之一的最优解，当我们找到另一个更高的柱子 height[j] 时，就意味着最高容量为 $maxArea = height[i] * |i - j|$。此时就算 j 的下一个柱子更高，也不会改变最大容量，甚至会因为更靠近 i 使得容量减少。 更一般的说，当 $min \\left \\lbrace height[i], height[j] \\right \\rbrace​$ 固定时，即使另一个柱子再高，也不会更新最大容量，反而会逐渐减少，所以每次迭代时都是让较矮的柱子改变。 另外，容易想到，当其中一个柱子 i 变高之后，与另外的柱子之前的柱子组合起来也不会使 i 的最大容量变得更大，这里不再说明。 Solution123456789101112class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int area = 0; for (int begin = 0, end = height.size() - 1; end != begin; ) &#123; area = max(area, (end - begin) * min(height[end], height[begin])); if (height[end] &lt; height[begin]) --end; else ++begin; &#125; return area; &#125;&#125;;","link":"/2018/10/18/【week7】11. Container With Most Water 解题报告/"},{"title":"【week8】713. Subarray Product Less Than K","text":"713. Subarray Product Less Than K 题目Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: 1234Input: nums = [10, 5, 2, 6], k = 100Output: 8Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Note: 0 &lt; nums.length &lt;= 50000. 0 &lt; nums[i] &lt; 1000. 0 &lt;= k &lt; 10^6. 解题报告题意很简单，找出满足乘积小于 k 的子数组的数目。 题目提示是使用双指针，我就先搞了个 i，j 作为子数组的头尾，可以很容易想到，如果 $product(i,j)&lt;k$，则 $product(i+1,j)&lt;k$ ，进一步地，假设 $count(i，j)$ 表示以 i 为起始直到 j 的满足条件的子数组数目，则 $count(i+1,j)=count(i,j)-1$，根据这个思路，我完成了 Solution 的大体逻辑。 主要思想是，使用 i 遍历数组，每次找到 j，满足 $product(i,j)\\ge k$，求得 $count(i,j)=j-i$， 如果 j == i，则说明 nums[i] &gt;= k，此时将 j 加一，然后 ++i。 时间复杂度为 $O(n)$。 社区有耗时更短的方法，思想似乎和我差不多，不过我是 $j=j+1\\ until\\ product(i,j)\\ge k$，社区的方法是 $i=i+1\\ until\\ product(i,j)&lt;k$。看上去差不多，不过运算次数快少了一半（我每次需要两次乘运算，而那个解法只需要一次除运算），我尝试简化自己的答案，不过没找到什么可以优化的地方。 Solution123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if (!k) return 0; int product = 1, count = 0; for (int i = 0, j = 0; i &lt; nums.size(); ++i) &#123; while (j &lt; nums.size()) &#123; if (product * nums[j] &lt; k) &#123; product *= nums[j]; ++j; &#125; else &#123; break; &#125; &#125; count += j - i; if (i != j) product /= nums[i]; else ++j; &#125; return count; &#125;&#125;;// others' solutionclass Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if (k == 0) return 0; int cnt = 0; int pro = 1; for (int i = 0, j = 0; j &lt; nums.size(); j++) &#123; pro *= nums[j]; while (i &lt;= j &amp;&amp; pro &gt;= k) &#123; pro /= nums[i++]; &#125; cnt += j - i + 1; &#125; return cnt; &#125;&#125;;","link":"/2018/10/25/【week8】713. Subarray Product Less Than K 解题报告/"},{"title":"【week9】714. Best Time to Buy and Sell Stock with Transaction Fee","text":"714. Best Time to Buy and Sell Stock with Transaction Fee 题目Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 1234Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 解题报告题意很简单，给定每天的股价和抛售的手续费，求最大收益。 刚开始看到这题我只知道要用 dp，但是没什么思路。后来受大佬点拨，发现这题其实并不难，是我想得太复杂了，老是想着抛售的策略。 由题可知，每天有两个操作：买股和卖股。那可以定义一个数组 sold[days], hold[days]，分别表示在第 i 天持有股票和不持有股票的对应最大收益。 那么状态转移方程就容易得到：当第 i 天持有股票的最大收益就是如果没有股票并买入股票的收益和继续持有股票的收益间的最大值；而第 i 天不持有股票的最大收益就是如果持有股票并卖出的收益和继续不持有股票的收益间的最大值。表达成数学公式即 $$sold[i]=max(sold[i-1],hold[i-1]+prices[i]-fee)$$ $$hold[i]=max(hold[i-1],sold[i-1]-prices[i])$$ 有了这个转移方程代码实现就很简单了。但是想起上课听老师讲的背包问题后，发现这个解还可以简化，因为状态转移的时候只用到了 sold[i-1] 和 hold[i-1] ，那么为什么不可以直接用两个变量把这两个值存起来呢？ 事实证明是可以的。只是在初始化两个变量时，hold 要赋值为 0，而 hold 要赋值为 -prices[0]，这是为了避免第一天不会没有买股票就卖出 1sold = max(0, -prices[0] + prices[0] - fee); // sold = 0 另外，更新的顺序并没有要求，如果先更新 hold，则可以理解为，先看看要不要卖掉股票，再看要不要买今天的股票；更新 sold 的话反之。 至于同时购入两支股票的情况也并不存在，因为 hold 的状态转移是 sold -&gt; hold（无股票时买进股票） 和 hold （持有股票）。同理无股票时卖出的情况也不会有。 Solution12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; if(prices.size() &lt;= 1) return 0; int sold = 0, hold = -prices[0]; for(int p : prices) &#123; sold = max(sold, hold + p - fee); hold = max(hold, sold - p); &#125; return sold; &#125;&#125;;","link":"/2018/10/30/【week9】714. Best Time to Buy and Sell Stock with Transaction Fee 解题报告/"},{"title":"【系分】第七周作业","text":"系统分析与设计第七周作业 使用 UMLet 建模：根据订旅馆建模文档，Asg-RH.pdf： 绘制用例图模型（到子用例） 给出 make reservation 用例的活动图 根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景 x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。 随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。 x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。 备注： 关于z公司投递员认证过程。一般采用用户登陆z公司，z公司用私钥签名的token（二维码包含公司名，用户ID，有效期等）；x公司扫描该二维码，用对应公钥验证该token。 分别用多泳道图建模三个场景的业务过程 场景一 场景二 场景三 根据上述流程，给出快递柜系统最终的用例图模型 用正常色彩表示第一个业务流程反映的用例 用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor 用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor","link":"/2019/05/24/【系分】第七周作业/"},{"title":"【系分】第二周作业","text":"系统分析与设计第二周作业 1、简答题 用简短的语言给出对分析、设计的理解。 分析：对问题和需求的调查研究 设计：满足需求的概念上的解决方案 用一句话描述面向对象的分析与设计的优势。 这种方法从认识论的角度面向对象方法改变了开发软件的方式，使得从客观世界到计算机的语言鸿沟变窄，更便于我们在软件中构建更真实的虚拟世界 简述 UML（统一建模语言）的作用。考试考哪些图？ UML是标准的图形表示法，有三种作用 作为草图：非正式、不完整的图，借助可视化语言的功能，可以用于探讨问题或解决方案空间的复杂部分。 作为蓝图：相对详细的设计图，用于逆向工程中对现有代码可视化或者是前向工程中的代码生成 作为编程语言：完成软件系统可执行规格的说明。 其具体的种类有： 用例图：用户角度：功能、执行者 静态图：系统静态结构 类图：概念及关系 对象图：某种状态或时间段内， 系统中活跃的对象极其关系 包图：描述系统的分解结构 行为图：系统的动态行为 交互图：描述对象间的消息传递 顺序图：强调对象间消息发送的时序 合作图：强调对象间的动态协作关系 状态图：对象的动态行为。状态-事件-状态迁移-相应动作 活动图：描述系统为完成功能而执行的操作序列 实现图：描述系统的组成和分布状况 构件图：组成部件及其关系 部署图：物理体系结构及软件单元的对应关系 考试会考用例图，静态图、行为图，实现图。 考试会考用例图，静态图、行为图，实现图。 从软件本质的角度，解释软件范围（需求）控制的可行性 由于软件本身的复杂性、不可见性、不一致性、可变性，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。因此，范围管理是软件项目管理的重中之重。 在多数情况下，客户与开发者能就项目的 20% 内容给出严格的需求约定，80% 的内容都是相对模糊的。因此，围绕客户目标，发现并满足客户感兴趣的内容是最关键的。 2、项目管理实践 看板使用练习（提交看板执行结果贴图，建议使用 Git project） 使用截图工具（png格式输出），展现你团队的任务 Kanban 每个人的任务是明确的。必须一周后可以看到具体结果 每个人的任务是1-2项 至少包含一个团队活动任务 kanban的任务皆已完成 UML绘图工具练习（提交贴图，必须使用 UMLet） 请在 参考书2 或 教材 中选择一个类图（给出参考书页码图号） 选取 《UML和模式应用（原书第三版）》P7 图1-5","link":"/2019/04/12/【系分】第二周作业/"},{"title":"字节跳动 & CVTE 面（凉）经","text":"大三了，该找实（bei）习（shua）了 字节跳动一面自我介绍…. 编程题：找二叉树任意节点间的最长路径 递归，找左右子树的最深节点，深度加起来，找最大。但是写得不够优雅 leetcode 543 GET 和 POST 的区别 随便说说 Cookie 和 Session 的区别 随便说说 既然 Cookie 不安全，那有没有增加安全的方法 脱口而出 “加密”，然后想不到了 提高cookie安全性的几种方式 Http 握手/挥手 挥手记得说 TIME_WAIT，并解释下原因 Https 了解过吗 不了解 SSL/TLS协议运行机制的概述 数据库索引的原理 说了下是 B+ 树 为什么不用红黑树之类的 有看过这题，但是回答的没什么底气，不会说 MySQL索引背后的数据结构及算法原理 写 SQL 都挺简单的，就是有一道 “查询一天内” 的忘了怎么做日期运算 100 的阶乘有几个 0 想到了算以 5 和 0 为各位的数字个数，在提示下又想出了 25，50等数。但是没有想出原理：算有多少个 5 的因子 项目的难点 标准高了就感觉没什么难点，低了就一堆，就随便说了个 用户态和内核态 说了是为了系统调用，但具体例子只说出了 I/O Linux探秘之用户态与内核态 地图上的道路拥挤程度是怎么做到的 答的是装载该地图的车向服务器发送信息（但是当时说了不够好），然后又问怎么才算拥挤，刚开始觉得速度慢不算拥挤，然后想了几种其他的方法，后来说了下面试官觉得算。 感觉还行，然后二面就凉了（太放肆了） 二面 编程题：给定几种硬币，求组成 N 元的方法 知道是动规，但是不会（明明很眼熟），然后浪费了大量时间 【算法27】硬币面值组合问题 进程间通信方法 答了共享内存和信号，还以为信号量不算，完全陌生 进程间通信的方式——信号、管道、消息队列、共享内存 数据库事务的原理 本来想从 ACID 说起，说说隔离级别和乐观锁悲观锁，结果 ACID 忘了。。 『浅入深出』MySQL 中事务的实现 后面基本都是安慰性问答，凉得一b，问了为什么选择后台。可能还问了一些技术问题，但是记不清了。 反思：该复习还是得复习，不要太自信。然后又投了一次。 CVTE本来想投后台的，结果一看 Java，算了（应该学学的），然后投了 C/C++ 软件开发。 一面 / 二面自我介绍… 我看你之前是写 js 的，为什么选择了 C++ 大一学过，感觉还挺熟的（其实没什么理由） 说说你觉得 js 和 C++ 的区别 随便说了下，提到了指针和类型 你刚才时候 C++ 类型太长不方便，有没有什么解决办法 说的 typedef 和宏，好像还有其他的？ C++有指针，那 js 是怎么样的 对象是引用的，基本类型是拷贝的 引用和指针的区别 引用是别名，指针是地址变量 函数参数的类型 引用，指针，拷贝，initializer_list（这个瞎说的） 怎么让指针内存回收简单点 说了智能指针（shared_ptr，unique_ptr，weak_ptr），解释了下三者，并说了下计数器回收 那你还知道其他语言的内存管理吗 不了解（好像 Java GC 也是这样的？ 多态是什么 说了下，还让手写个例子（忘了加 public，尴尬 虚函数是怎么实现的 来之前看过，说了下虚函数表 多态还有什么实现方式 还有其他的吗？只说了重载，回去终于想起了模板 计算机网络有多少层，写一下 写了下，还要举个协议例子 socket 是干嘛用的 多路复用，多路分解什么的，答的很乱 Linux Socket编程（不限Linux） 大致是个什么流程？写一下 写的像 C++ 和 Python 混杂，简直如同伪代码，太菜了。大致就是 bind，listen，accept 什么的 怎么知道请求发给谁 先发给网关，然后网关路由器根据路由表转发 网关是怎么哪来的 DHCP 分配的 怎么知道转发给谁 根据子网掩码和 ip，简单说了下路由选择算法 DNS 是干嘛的 获取域名对应的 ip，或是知道这个 ip 的域名服务器（还有别名，邮件什么的 DNS域名解析中A、AAAA、CNAME、MX、NS、TXT、SRV、SOA、PTR各项记录的作用 你的博客是怎么搭的（这也要问的吗 Hexo + Minos 都是自己写的吗 基本都是 做道题吧：从 ifconfig 里找到 ip，假设只有一张网卡 用循环写了，面试官指出了可以改的地方：参数用 const string &amp; 和 可以用 string.find 找关键词。 大概是这些，晚上一查二面都直接过了（好像其他人也是）。然后 hr 面被一堆 “如果/你觉得/遇到过” 等问题击败。。","link":"/2019/03/08/字节跳动 & CVTE 面（凉）经/"},{"title":"字节跳动暑假实习面经","text":"上次挂了之后，我又来了。 头条这次很快，我一个下午就面完了 3 次技术面试。所以很多题都可能记混了。 一面自我介绍… 你印象最深的一个项目 我说了自己的抢课脚本 类似这种脚本你觉得应该怎么写 我只写过这一个呀，不会，然后又问我就这个项目是怎么写的，我就说了下流程。 怎么不让服务器发现 伪造头部，操作频率不要太频繁，不会。 后端应该怎么判断爬虫 这个我也不了解，就说了下操作的频率，乱说，现在想起来应该有验证码的方法。。 前端如何判断 不会（我投的是后端。。不是爬虫，也不是前端 一道括号匹配的常规栈算法题，很水，但是我还是写错了。。 根据前序遍历和中序遍历还原二叉树，这个也很水。 就面完了。问我还有什么问题，我问我这两题做的怎么样（不知道问什么了 二面自我介绍… 做过什么项目 实验室项目balabala HTTP 状态码了解吗，503 知道吗 不知道（查了下，Service Unavailable 服务不可用 那你了解多少 2XX 表示成功发起请求，3XX 表示重定向，比如 301,302，4XX 表示客户端错误，比如 404 Not Found，403 Forbbiden，5XX 表示服务器错误。 CORS了解过吗 又是不是很懂，跨域限制 怎么发送跨域请求 服务器取消限制（瞎说开始 除了这个呢 不会了 HTTP 头部了解多少，说几个 Accept-*，Cookie，Cache-Control，ETag，Origin，Referer，每一个都随便解释一下，然后就想不起来其他的了，让面试官说几个我解释，他问了 User-Agent。 说下段和页 页是定长的，段是不定长的，段是逻辑的，比如代码段，数据段。页是“比较物理”的（说的不准确） 怎么寻页和段 段不太记得了，页要根据地址映射找到 进程调度有什么算法 先到先服务，最短作业优先，最短剩余时间优先，优先级调度，轮转，多级队列反馈 怎么知道剩余时间 不会，印象中是有概率的 Redis 数据类型有哪些 string，set，list，zset，hash Redis 的底层数据结构怎么实现的知道吗 不知道（之前收藏过了但是懒得看。。 算法题 给定整数数组 a，元素满足 1 &lt;= a[i] &lt;= n (n 为 a 的长度)，有些元素出现一次，有些元素出现两次，找出所有出现两次的元素 问可不可以用变量，说不可以，问我用变量怎么做，我说可以哈希。我先想到的是先排序再遍历，时间复杂度是 $O(n\\log n)$。问我有没有 $O(n)$ 的方法，想了半天没想到。面试官提示我可以改变数组的状态，恍然大悟，不过还是想偏了，又想了半天才想到解法： 12345678910111213vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; int offset = nums.size(); vector&lt;int&gt; ans; for (int i = 0; i &lt; offset; ++i) &#123; int index = (nums[i] - 1) % offset; if (nums[index] &gt; offset) &#123; ans.push_back(index + 1); &#125; else &#123; nums[index] += offset; &#125; &#125; return ans;&#125; 链表题 有两条链表，它们可能在某一点交叉，找到这个交叉点 先问我这个形状是怎么样的，我不假思索先说了 X，然后反口说 Y。我又问可不可以用变量，依然不可以。他问如果可以的话怎么做，我又说哈希。 想了一会想了出来：先设两个链表指针指向两个链表，然后同时遍历链表，如果相遇直接返回，如果一个到尾部了，另一个还没有，则让没有到底的继续遍历，并记下走的步数 s。s 则为两条链表交叉前的长度差，所以这时候再重新让两个指针指向链表头，并让长的那个先走 s 步，再同时遍历链表，相遇则返回。时间复杂度是 $O(n)$。（代码丢了） 三面自我介绍… MySQL 索引原理 B+树，聚簇索引，辅助索引，哈希索引都说了下 给了道设计系统的题给我 订单系统设计 order_table id, create_time, product_id, xxx, … 某一款产品所有的订单 某天所有订单 最近 n(n&lt;30)天 某款产品 的所有订单 SQL index 缓存设计 先写 SQL，特意问了下需要取出什么字段： 1234567891011121314151.SELECT *FROM order_tableWHERE product_id = 1;2.SELECT *FROM order_tableWHERE create_time BETWEEN NOW() AND DATE_SUB(NOW(), INTERVAL 1 DAY);3.SELECT *FROM order_tableWHERE product_id = 1 AND create_time BETWEEN NOW() AND DATE_SUB(NOW(), INTERVAL 1 MONTH); 索引的话，主键索引肯定有的，(product_id, create_time) 建一个联合索引，经面试官提醒补充一个 create_time 索引 缓存的话用 Redis，因为不知道 Redis 可否遍历 key，如果可以的话可以直接存 product_id 作为 key，然后设过期时间（面试官直接 pass 这个方案）。不可以遍历的话，存一个 list，但是要每天更新。然后问我 key 怎么设计，我说 &lt;product_id&gt;_1month 这样。 Redis 的底层数据结构知道吗 跳表，字典什么的（二面结束后看了一下，还好没问细节 概率题： 100个旅客按顺序准备登机，每个人都拿着对应的座位票的number，第一个人因为喝醉了，他随机选一个座位，其他的旅客选择座位的规则是： 1. 如果他对应的座位没被坐就坐原来的 2. 如果被别人做了，他就随机从剩余的座位里选一个。 问第100个人坐到自己座位#100的概率是多少？ 算了半天算不出来，提示可以从简单的归纳，还是不会，答案是 $1/2$ 算法题： 输入 n […, (start_time_i, end_time_i), …] timestamp int 条件: - 选择听一场后必须全程参加 - 时间不能重叠 - 不考虑切换成本 问题: 实现一个算法，找出最多能听多少场演唱会 [(1, 3), (2, 4), (5, 6)] =&gt; 2 （做过），简单问了下可不可以边界重叠就开始做 123456789101112131415161718192021class Cmp &#123; public: static bool cmp(const pair&lt;int, int&gt; &amp;l, const pair&lt;int, int&gt; &amp;r) &#123; return l.second &lt; r.second || (l.second == r.second &amp;&amp; l.first &lt; r.first); &#125;&#125;;int getTimes(vector&lt;pair&lt;int, int&gt; &gt; times) &#123; sort(times.begin(), times.end(), Cmp::cmp); int end = -1; int count = 0; for (int i = 0; i &lt; times.size(); ++i) &#123; if (times[i].first &gt; end) &#123; end = times[i].second; ++count; &#125; &#125; return count;&#125; cmp 函数都写错几次。。我的算法题没救了 还有什么问题要问的吗 头条的技术栈是怎么样的（虽然知道是 python+go），然后我又问 python 的性能不会有问题吗（发出菜鸡的提问） 面试官突然想起来一样的问我 “我们北京也有设立总部，你有没有想法” 我觉得实习几个月不太想去那么远，连深圳都不太想去，想在广州（拒绝offer发言，别学） 感觉三面面的比较久，但是也想不起什么题目，先这样吧。 总结算法太菜了，数学也不行，基础不扎实，扩展知识也不丰富，这都没挂。不过 3 次面试问了 5 道编程题我也是第一次见，虽然都挺水的。","link":"/2019/03/27/字节跳动暑假实习面经/"},{"title":"排序I 插入排序与Shell排序","text":"前言插入排序是一种典型的基于相邻元素交换的简单算法（还有冒泡排序和选择排序等），而Shell排序则在某种程度上与插入算法类似，故而放在一起说。（至于冒泡和选择？一个插入不就够了吗） 插入排序插入排序的思想很简单，假设有一个序列[x1, x2...xn]，当对第k个元素进行排序时，把这个元素插入前面k-1个元素（已经有序）中合适的位置中（依然保持有序），也就是说，若保证前k-1个元素有序，插入第k个元素后前k个元素也将保持有序，那么经过n次插入后，整个序列也将有序。 C++实现实现中避免了显式的交换，而是将比nk大的元素都往后移了一位。123456789void insertsort(vector&lt;int&gt; &amp;ele) &#123; int temp = 0, j = 0; for (int index = 1; index &lt; ele.size(); ++index) &#123; temp = ele[index]; for (j = index; j &gt;= 1 &amp;&amp; temp &lt; ele[j - 1]; --j) ele[j] = ele[j - 1]; ele[j] = temp; &#125;&#125; 时间复杂度插入排序由代码可见，最坏情形下（如果反序输入），那么计算总数将为 $$\\sum_{i=2}^{n}i = 2 + 3 + 4 + … + N = \\Theta (N^2)$$ 实际上，插入排序的平均情形也是$\\Theta (N^2)$，而如果事先排好序，那么时间复杂度将为 $O(N)$ 。 简单排序算法的下界首先，定义逆序的概念：在数组中具有 $i&lt;j$ 且 $A[i] &gt; A[j]$ 的有序对 $(A[i], A[j])$，而这正是简单排序算法的执行交换次数，每交换一次（非直接）不按顺序排列的两个元素将会消除一个逆序。当数组中不存在逆序时，则数组有序。 定理一：N个互异数的数组平均逆序数是 $N(N-1)/4$ 证明：若一个数组有N个数，则将有$N(N-1)$个有序对$(A[i], A[j])$，而其中$i&lt;j$的有$N(N-1)/2$，那么其中为逆序的平均便有$N(N-1)/4$个 定理二：通过交换相邻元素进行排序的任何算法平均需要 $\\Omega(N^2)$ 的时间 证明：初始的平均逆序数为$N(N-1)/4 = \\Omega(N^2)$，而每一次交换只减少一个逆序，因此需要$\\Omega(N^2)$次交换。 Shell排序Shell排序也称缩小增量排序(diminishing increment sort)，由Donald Shell发明。 希尔排序使用一个增量序列 $h_1, h_2, …, h_t$ ，只要$h_1=1$，那么任意增量序列都是可以的，因为此时排序等同于插入排序，当然不同序列的效率也有所不同。在使用$h_k$进行增量排序后，对于任意的$i$都有$A[i]&lt;A[i+k]$(假设存在)，即所有相隔为$h_k$的元素都被排序，此时称数组为$h_k$-排序的（$h_k$-sorted）。而希尔排序的一个重要性质是，一个$h_k$-sorted的数组在之后的$h_{k+1}$排序中也将保持其$h_k$-排序的性质。 C++实现实际上是对任意的$i$对应的序列$A[i], A[i+h_k], A[i+2h_k]…$进行插入排序。123456789101112131415161718192021222324252627void shellsort(vector&lt;int&gt; &amp;ele, string choice = \"Shell\") &#123; vector&lt;int&gt; *seq; if (choice == \"Sedgewick\") &#123; seq = &amp;Sedgewick; &#125; else if (choice == \"Hibbard\") &#123; seq = &amp;Hibbard; &#125; else&#123; seq = new vector&lt;int&gt;; for (int i = ele.size() / 2; i &gt; 0; i /= 2) seq -&gt; insert(seq -&gt; begin(), i); &#125; int temp = 0, j = 0, k = seq -&gt; size() - 1; while ((*seq)[k] &gt; ele.size() / 2) --k; for (int inc = (*seq)[k]; true; inc = (*seq)[--k]) &#123; for (int index = inc; index &lt; ele.size(); ++index) &#123; temp = ele[index]; for (j = index; j &gt;= inc; j -= inc) if (ele[j - inc] &gt; temp) ele[j] = ele[j - inc]; else break; ele[j] = temp; &#125; if (inc == 1) break; &#125;&#125; 类实现选择哪一种增量排序视情况我给了用户（不存在的）自己选择，故而有了string参数，并将增量序列封装成了private，这样写看上去有点low，但比起现场生成个人认为通过while判断从哪里开始更有效率，而如果选择了Shell序列，则构建一个序列也与之前的没差多少，具体可见vegchic/learn-ds/sort/shellsort(insert).cpp) 时间复杂度由于有不同的序列，这里只列出几种不同序列的时间复杂度。具体可见wikipedia 序列 计算公式 具体 最坏情形 Shell $\\left\\lfloor\\frac{N}{2^k}\\right\\rfloor\\quad$ $\\left\\lfloor\\frac{N}{2}\\right\\rfloor,\\left\\lfloor\\frac{N}{4}\\right\\rfloor,…,1$ $\\Theta(N^2)$ Hibbard $2^k-1$ $1,3,7,15…$ $\\Theta(N^{\\frac{3}{2}})$ | Sedgewick | $\\begin{cases}9(4^{k-1} - 2^{\\frac{k}{2}}) + 1\\text{ }k\\text{ is even} \\\\ 4^{k+1} - 6\\cdot2^{(k+1)/2} + 1\\text{ }k\\text{ is odd}\\end{cases}$ | $1,5,19,41,109,…$ | $\\Theta(N^{\\frac{4}{3}})$ | 测试以后的排序测试大概都是这个套路+valgrind了，就不贴了1234567891011121314151617181920212223242526272829#include &lt;random&gt;#define TEST 999void test() &#123; sort solution; vector&lt;int&gt; test; default_random_engine e(time(0)); uniform_int_distribution&lt;unsigned&gt; u(0, TEST); for (int i = 0; i &lt; TEST; ++i) &#123; test.push_back(u(e)); &#125; solution.shellsort(test, \"Shell\"); int prev = 0; for (int index = 0; index &lt; TEST; ++index) &#123; if (prev &gt; test[index]) cout &lt;&lt; \"error\" &lt;&lt; endl; prev = test[index]; &#125; vector&lt;int&gt; test2; for (int i = 0; i &lt; TEST; ++i) &#123; test2.push_back(u(e)); &#125; solution.insertsort(test2); prev = 0; for (int index = 0; index &lt; TEST; ++index) &#123; if (prev &gt; test2[index]) cout &lt;&lt; \"error\" &lt;&lt; endl; prev = test2[index]; &#125;&#125; 结语最近学到了排序，虽然以前也已经开始用了，但是终归系统的学习了一下，故而写两篇笔记记录下自己学的。 ReferenceShellsort 《数据结构与算法分析——C语言描述》,Mark Allen Weiss","link":"/2017/11/11/排序I 插入排序与Shell排序/"},{"title":"排序II 归并排序与快速排序","text":"前言emmm，也没什么说的，归并排序和快速排序都是一种“分而治之”的思想实现，所以就一起说了，至于堆排序就不说了，毕竟我还要写二项队列。。 归并排序归并排序的核心思想很简单：把数组对半拆分-&gt;分别排序-&gt;有序合并。明白了这个就可以采用递归来实现，基准条件就是数组为空时。（虽然这么说但第一次写完全不会。 gif By Swfung8 实现对半拆分是递归实现。有序合并可以使用两个index分别指向要合并的数组，然后根据大小将元素放进temp中（temp为中转数组，整个排序只需要一个） src123456789101112131415161718192021222324252627282930313233class MergeSort &#123; private: void msort(vector&lt;int&gt; &amp;arr, int temp[], int start, int end) &#123; if (start &lt; end) &#123; int center = (start + end) / 2; msort(arr, temp, start, center); msort(arr, temp, center + 1, end); merge(arr, temp, start, center + 1, end); &#125; &#125; void merge(vector&lt;int&gt; &amp;arr, int temp[], int start, int middle, int end) &#123; int i = start, j = middle, begin = start; while (i &lt; middle &amp;&amp; j &lt;= end) if (arr[i] &gt; arr[j]) temp[start++] = arr[j++]; else temp[start++] = arr[i++]; while (i &lt; middle) temp[start++] = arr[i++]; while (j &lt;= end) temp[start++] = arr[j++]; for (int k = begin; k &lt;= end; ++k) arr[k] = temp[k]; &#125; public: vector&lt;int&gt;&amp; sort(vector&lt;int&gt; &amp;arr) &#123; if (!arr.size()) return arr; int *temp = new int[arr.size() * sizeof(int)]; msort(arr, temp, 0, arr.size() - 1); return arr; &#125;&#125;; 时间复杂度假设数组的大小为$N=2^k$，则时间的递推公式为 $$T(1)=1$$ $$T(N)=2T(N/2)+N$$ 上式中$T(1)$消耗常数时间，而$T(N)$则消耗将其子数组排序的时间和自身合并的时间。经过计算可得 $$T(N)=NT(1)+N\\log N=N\\log N+N$$ 所以时间复杂度为$O(N\\log N)$ 快速排序顾名思义，这个排序很快，是平均情形下最快的已知算法。快排的核心算法也很简单，假设有一个数组$S$： 如果$S$中元素个数为0或1，则返回 取$S$任一元素$v$为枢纽元（pivot） 将$S-\\lbrace v \\rbrace$分成两个不相交的集合：$S_1=\\lbrace x\\in S-\\lbrace v\\rbrace \\mid x\\le v\\rbrace $和$S_2=\\lbrace x\\in S-\\lbrace v\\rbrace\\mid x\\ge v\\rbrace$ 返回$quicksort(S_1)$后，继随$v$，继而$quicksort(S_2)$，即三者按该顺序存放在$S$中。 换个角度看这个排序，即每次选出一个枢纽元，并将其放在它应该在的地方（排序后的位置） gif By en:User:RolandH 选取枢纽元最简单的方法或许是直接选取第一个或最后一个元素作为枢纽元，但这样是很糟糕的选法，如果输入为有序数组，则排序将产生一个很坏的分割（反序亦然），而且会花费O(N^2)时间却什么都没做。 还有一种方法是使用随机数生成，但这会花费额外的时间代价，所以也不可取。 这里采用的是三数中值分割法（Median-of-Three Partitioning）。如果是想要最好的分割，自然是对半分，即选取中值作为枢纽元，但中值的计算又要付出代价，所以这里直接选取三个元素并将其中值作为枢纽元，这三个元素也不需随机，直接使用左端，中心位置，右端的三个元素即可。 分割策略将枢纽元放在A[right-1]中，这样就可以定义两个下标i, j，分别指向A[left]和A[right-1]，并相向而行，若下标指向元素同时不符合条件（A[i]应小于pivot，A[j]应大于pivot），则交换二者，而当i&gt;j时，则分割完毕。对于与枢纽元相等的元素，这里也进行了交换。 对于小数组($N\\le20$)，快排不如插入排序好，所以可以define一个截止范围（cutoff range），数组大小小于时则使用插入排序，也避免了数组过小三数中值无法正确运行的情况。 src1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class quickSort &#123; private: inline int median(vector&lt;int&gt; &amp;arr, int left, int right) &#123; int med = (left + right) / 2; if (arr[left] &gt; arr[med]) swap(arr[left], arr[med]) if (arr[med] &gt; arr[right]) swap(arr[med], arr[right]) if (arr[left] &gt; arr[med]) swap(arr[left], arr[med]) swap(arr[med], arr[right - 1]); return arr[right - 1]; &#125; void qsort(vector&lt;int&gt; &amp;arr, int left, int right) &#123; if (right - left &gt;= CUTOFF) &#123; int pivot = median(arr, left, right); int i = left, j = right - 1; while (i &lt; j) &#123; while (arr[++i] &lt; pivot) &#123;&#125; while (arr[--j] &gt; pivot) &#123;&#125; if (i &lt; j) swap(arr[i], arr[j]) &#125; swap(arr[i], arr[right - 1]); qsort(arr, left, i - 1); qsort(arr, i + 1, right); &#125; else &#123; insertSort(arr, left, right); &#125; &#125; void insertSort(vector&lt;int&gt; &amp;arr, int left, int right) &#123; for (int i = 1; i &lt;= right; ++i) &#123; int temp = arr[i], j; for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp; --j) arr[j] = arr[j - 1]; arr[j] = temp; &#125; &#125; public: vector&lt;int&gt;&amp; sort(vector&lt;int&gt; &amp;arr) &#123; if (!arr.size()) return arr; qsort(arr, 0, arr.size() - 1); return arr; &#125;&#125;; 时间复杂度最坏的情形是枢纽元始终是最小的元素，递推式为 $$T(N)=T(N-1)+cN, N&gt;1$$ 此时时间复杂度为$O(N^2)$； 最好的情形是枢纽元恰巧位于中间，递推式为 $$T(N)=T(N/2)+cN, N&gt;1$$ 此时时间复杂度为$O(N\\log N)$； 平均情形时假设子数组的大小都是等可能的，为$1/N$，则递推式为 $$T(N)=\\frac{2}{N} \\left[\\sum^{N-1}_{j=0}T(j)\\right]+cN$$ 此时时间复杂度为$O(N\\log N)$ Refernce《数据结构与算法分析——C语言描述》,Mark Allen Weiss For MoreMergesort Quicksort","link":"/2017/11/13/排序II 归并排序与快速排序/"},{"title":"谈谈对Promise的小理解","text":"初识Promise写完callback的一个异步编程小作业之后，去看了看Promise，惊为天人，还以为能把异步函数封装成同步函数（现在想想是思维错误，结果用的时候一堆bug，参考了各路博客和MDN的资料后，才发现自己理解错了，故而小记一下 第一次用刚开始写时，我是类似这样写的 123456789var p = new Promise(resolve =&gt; &#123; resolve();&#125;).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(123); &#125;, 1000);&#125;).then(() =&gt; &#123; console.log(456);&#125;); 这样写正是我刚才说的异步变同步的弱智操作。实际异步编程的优越性正在于它的异步性，而我一味追求同步（阻塞线程）无疑是走了误区。 理解MDN的资料是这样说的： A Promise is in one of these states: pending: initial state, neither fulfilled nor rejected. fulfilled: meaning that the operation completed successfully. rejected: meaning that the operation failed. 其实个人觉得这个没什么卵用，Promise的实际使用其实和这个没什么关系，只是把return和throw变成了resolve和reject，对于简单的callback，可以直接传函数参数作为resolve和reject，而且代码量似乎还多了一点。不过如果是“Callback Hell”或是比较特殊的异步要求，Promise就体现了他的强大。 个人认为Promise的核心其实只有以下一段： 1234567var p = new Promise((resolve, reject) =&gt; &#123; //async&#125;).then(() =&gt; &#123; //...&#125;).catch(() =&gt; &#123; //...&#125;); 所以如果要实现链式的话，就需要在每个then的函数里return一个新的Promise对象，刚开始我觉得这样很麻烦，似乎没有改变callback的弊端，但再仔细想想，如果把每个异步函数包装成一个函数，则then的参数便只是一个简单函数名字，多个then放在一起岂不是比callback hell赏心悦目且直接？而且对于调试和维护也会更方便。 12345var p = new Promise(async) .then(async1) .then(async2) .then(async3) .catch(reject); 至于其他的Promise.all和Promise.race因为还没用过，所以谈不上理解，但是all的好处显而易见，假设有多个异步请求同时进行，当它们都完成时便可以触发某个事件，这用all可以说是很轻松了，我之前做作业时是每个请求都判断一次当前状态是否满足条件，相形见绌。 结语这篇文是在做完web作业的晚上随便写写的（毕竟很久没更新了），理解谈不上多深层，只是使用的感受罢了。ES7有async和await（听说是根据tj大神的co加的，膜），据说是解决异步的终极方案，然而我还没看。参考了阮一峰的ES6入门和MDN","link":"/2017/11/24/谈谈对Promise的小理解/"},{"title":"逆波兰表达式应用--计算器","text":"简介 逆波兰表达式（Reverse Polish notation） 也叫后缀表达式，可以由表达式二叉树的后序遍历得到（中序即可得到日常使用的表达式）。本文简单介绍其算法内容并实现计算器。 示例 对于表达式1+2*3+(5*6),其后缀表达式为123*+56*+ Input&amp;Output input：一个符合规范的表达式，如1+2*3+(5*6)，中间无空格，支持负数 output：计算结果 算法细节从中缀到后缀的转换 给定一个表达式，从左到右开始读取： 当读到一个操作数时，将其放进postfix[]中 当读到一个操作符时，检查栈的状态，将元素弹出并放进postfix[]中直至栈顶为优先级更低的元素（如’*‘不低于’*‘且高于’+’)，将该操作符压入栈中，注意，’(‘不该被弹出直至读到一个’)’ 当读到’(‘时，直接压入栈中，读到’)’时，检查栈的状态，将元素弹出并放进postfix[]中直至弹出一个’(‘，’)’不压入栈中，注意，’)’和’(‘不放入postfix[]中 当读取完毕时，将栈中所有元素弹入postfix[]中。 在这里对于负数的处理是将其看为一条”0-x”的表达式 至此，得到了后缀表达式postfix[]。 后缀表达式的计算（核心）得到后缀表达式后，继续从左到右读取： 遇到操作数直接压入栈中 遇到操作符时，弹出栈顶两个元素，并按照操作符进行运算，将结果压入栈中 读取完毕时，栈中仅剩一个元素，此时弹出并返回即可得到结果 Source Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define MAX_SIZE 100#define EMPTY -1using namespace std;class Stack &#123; private: string sta[MAX_SIZE]; int topEle; public: Stack() &#123; topEle = EMPTY; &#125; string pop() &#123; if (topEle != EMPTY) return sta[topEle--]; else return \"\"; &#125; void push(string i) &#123; if (topEle != MAX_SIZE - 1) sta[++topEle] = i; &#125; string top() &#123; if (topEle != EMPTY) return sta[topEle]; &#125; bool isEmpty() &#123; return topEle == EMPTY; &#125;&#125;;int stoi(string str) &#123; int num = 0, i = 0; if (str[0] == '-') ++i; for ( ; i &lt; str.length(); ++i) &#123; num = num * 10 + str[i] - '0'; &#125; if (str[0] == '-') num = -num; return num;&#125;string getResult(string postfix[], int size) &#123; Stack data; char num[MAX_SIZE]; memset(num, 0, MAX_SIZE * sizeof(char)); for (int i = 0; i &lt; size; ++i) &#123; if (postfix[i] == \"+\") &#123; int right = stoi(data.pop()); int left = stoi(data.pop()); sprintf(num, \"%d\", left + right); data.push(string(num)); &#125; else if (postfix[i] == \"-\") &#123; int right = stoi(data.pop()); int left = stoi(data.pop()); sprintf(num, \"%d\", left - right); data.push(string(num)); &#125; else if (postfix[i] == \"/\") &#123; int right = stoi(data.pop()); int left = stoi(data.pop()); sprintf(num, \"%d\", left / right); data.push(string(num)); &#125; else if (postfix[i] == \"*\") &#123; int right = stoi(data.pop()); int left = stoi(data.pop()); sprintf(num, \"%d\", left * right); data.push(string(num)); &#125; else &#123; data.push(postfix[i]); &#125; memset(num, 0, MAX_SIZE * sizeof(char)); &#125; return data.pop();&#125;string compute(string tar) &#123; string postfix[MAX_SIZE]; Stack operation; string num(\"\"); string empty(\"\"); int pos(0); for (int i = 0; i &lt; tar.length(); ++i) &#123; if (tar[i] &lt;= '9' &amp;&amp; tar[i] &gt;= '0') &#123; num.push_back(tar[i]); &#125; else &#123; if (num != \"\") &#123; postfix[pos++] = num; num = \"\"; &#125; else if (tar[i] == '-') &#123; postfix[pos++] = \"0\"; &#125; if (tar[i] == '+' || tar[i] == '-') &#123; while (!operation.isEmpty() &amp;&amp; operation.top() != \"(\") postfix[pos++] = operation.pop(); empty.push_back(tar[i]); operation.push(empty); &#125; else if (tar[i] == '*' || tar[i] == '/') &#123; while (!operation.isEmpty() &amp;&amp; operation.top() != \"(\" &amp;&amp; operation.top() != \"+\" &amp;&amp; operation.top() != \"-\") postfix[pos++] = operation.pop(); empty.push_back(tar[i]); operation.push(empty); &#125; else if (tar[i] == '(') &#123; empty.push_back(tar[i]); operation.push(empty); &#125; else if (tar[i] == ')') &#123; while (!operation.isEmpty() &amp;&amp; operation.top() != \"(\") postfix[pos++] = operation.pop(); operation.pop(); &#125; empty = \"\"; &#125; &#125; if (num != \"\") postfix[pos++] = num; while (!operation.isEmpty()) postfix[pos++] = operation.pop(); return getResult(postfix, pos);&#125;int main() &#123; string tar; while (cin &gt;&gt; tar) &#123; if (tar == \"q\") break; cout &lt;&lt; compute(tar) &lt;&lt; endl; tar = \"\"; &#125; return 0;&#125; 结语 这是我学栈后写的一个小程序，参考自《数据结构与算法分析——C语言描述》, Mark Allen Weiss，函数功能分工实现看上去可能比较臃肿和混乱。也没有进行表达式有效检测，主要实现算法。 感谢@chLFF 帮我指出本文的错误（陷入了“反正也没人看我为什么要改”的思考","link":"/2017/10/09/逆波兰表达式应用--计算器/"},{"title":"Vi, java, Ant, Junit自学报告","text":"实训报告。简单的记录自己所学，然而实训之后就忘光了。 Vi/VimVi是Linux系统自带的命令行编辑器，其功能强大，且无需GUI即可运行。而Vim是Vi的进阶版本，其功能更强大，且有丰富的插件，使其深受程序员喜爱。 Vi分为三种模式，命令行模式（command mode），插入模式（insert mode），底行模式（Last Line Mode，有些地方称为command-line mode）。 使用进入时只需在命令行输入vi file即可打开file，并进入命令行模式。 命令模式输入i可直接进入插入模式（还有其他指令），按下Esc可从插入模式切换回来。在命令行模式中可移动光标，删除字符等操作，下面列出部分操作。 指令 作用 移动光标 h或左箭头键(←) 光标左移一格 j或下箭头键(↓) 光标下移一格 k或上箭头键(↑) 光标上移一格 l或右箭头键(→) 光标右移一格 0 移到此行开头 $ 移到此行末尾 G 移到最后 gg 移到开头 ^ 移到此行第一个非空白字符 w 移到下一个字的开头 e 移到这一个字的字尾 b 移到上一个字的开头 #l 移到此行的第#个位置，如：5l 删除 x 删除下一个字符 X（大写） 删除前一个字符 dd 删除此行 #x，#X 类比#l #dd 从此行开始删除#行 复制 yw 将光标所在之处到字尾的字符复制到缓冲区中 yy 复制该行到缓冲区 #yw，#yy 类比以上 p 将缓冲区内的字符贴到光标所在位置 替换 r 替换光标所在之处字符 R 替换光标所到之处的字符，直到按下「ESC」键为止 恢复 u 撤销 更改 cw 更改光标所在处的字到字尾处 c#w 更改#个字（不是字符） 跳行 [ctrl] + g 列出光标所在行的行号 #G 表示移动光标至文章的第#行行首 插入模式无需多言，有三种进入方式。只需记住其功能是插入即可 按i进入插入模式后，是从光标当前位置开始输入文件。 按a进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字。 按o进入插入模式后，是插入新的一行，从行首开始输入文字。 底行模式在命令行模式下按下冒号（[:]）即可进入底行模式。 指令 作用 set nu 每一行都会显示行号 set nonu 取消显示行号 w 保存 w! 强制保存 q 退出Vi q! 不保存强制退出 wq 保存并退出 /word 查找word，可按n往后继续寻找 ?word 查找word，可按n往前继续寻找 !command 暂时离开Vi并执行command命令 Vi/Vim总结Vi/Vim功能强大，并非几日便能速成，需要长期使用才能熟能生巧。其在ssh中显得尤为重要。 另外就是，实训给出的文档有几个错误，比如[0]的作用。 参考： 鳥哥的 Linux 私房菜 JavaJava的基本语法大部分与C/C++并无不同，但是在设计上比C/C++更“亲民”，下面通过简单的学习总结其特点（充满主观性）。 变量引用。不同于C/C++，Java没有指针，取而代之的是对象的引用。对于一个基本类型的变量，变量即是其本身，但对于一个对象变量，变量只是这个对象的引用，也就是说，变量存在栈中，而对象存在堆中，变量指向这个对象。 GC（Garbage Collection）。Java无需手动释放内存，它的垃圾回收机制会将无用的内存回收，基本原则便是回收不可再达到的对象内存，即该对象已无任何引用。 完全的面向对象。OOP三大特性：继承，封装，多态，Java都支持的很好，没有C/C++的多重继承，Java使用了单继承与接口，实现了多重继承的功能。 丰富的高级特性和api。反射，容器，多线程，泛型，网络编程，包（package），Java的高级特性方便了程序员的使用，也封装了底层的许多细节。 独特的编译和执行行程。不同于类似C/C++的编译性语言，也不是类似JavaScript的解释性语言，Java被称为半解释语言。源代码首先会被编译器编译成字节码（.class），字节码再由JVM解释运行，具有高性能，当然还比不上C/C++。 生态繁荣。Java应用广泛，JVM为其跨平台提供了有力的支持，Android开发为其注入了新鲜血液，Java的生态繁荣，许多学习资料随处可得，丰富的源码库也让使用者使用起来更轻松。 因为之前接触过C#，所以学起Java大概会轻松一丢丢，但是要将其运用到开发中还是不容易的，需要实际动手才能领略其特点。 AntAnt,是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，有点类似于C/C++的make，其没有单独的语法，而是通过xml来构建，免去了重新学习的时间。下面是一个简单的build.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project name=\"Caculator\" default=\"compile\" basedir=\".\"&gt; &lt;!-- set global properties for this build --&gt; &lt;property name=\"src\" location=\"src\"/&gt; &lt;property name=\"build\" location=\"build\"/&gt; &lt;property name=\"lib\" location=\"lib\"/&gt; &lt;property name=\"entry\" value=\"com.vegchic.junittest.HelloWorld\"/&gt; &lt;target name=\"init\"&gt; &lt;!-- Create the time stamp --&gt; &lt;tstamp/&gt; &lt;!-- Create the build directory structure used by compile --&gt; &lt;mkdir dir=\"$&#123;build&#125;\"/&gt; &lt;/target&gt; &lt;target name=\"compile\" depends=\"init\" description=\"compile the source\"&gt; &lt;!-- Compile the java code from $&#123;src&#125; into $&#123;build&#125; --&gt; &lt;javac srcdir=\"$&#123;src&#125;\" destdir=\"$&#123;build&#125;\"/&gt; &lt;/target&gt; &lt;target name=\"run\" depends=\"compile\"&gt; &lt;java classname=\"$&#123;entry&#125;\" fork=\"yes\" classpath=\"$&#123;build&#125;\"/&gt; &lt;/target&gt; &lt;target name=\"test\" depends=\"compile\"&gt; &lt;junit&gt; &lt;classpath location=\"$&#123;build&#125;\"/&gt; &lt;formatter type=\"brief\" usefile=\"false\"/&gt; &lt;test name=\"com.vegchic.test.HelloWorldTest\"/&gt; &lt;/junit&gt; &lt;/target&gt; &lt;target name=\"clean\" description=\"clean up\"&gt; &lt;!-- Delete the $&#123;build&#125; and $&#123;dist&#125; directory trees --&gt; &lt;delete dir=\"$&#123;build&#125;\"/&gt; &lt;/target&gt;&lt;/project&gt; 由xml简洁易懂的语法容易看出，这个build.xml有5个命令，分别为init，compile，run，test，run。 &lt;project&gt;即使项目的信息描述，default为默认命令，如果不执行默认命令则需输入ant &lt;commandName&gt;。 &lt;property&gt;是一些变量的定义。 &lt;target&gt;是需要运行的命令，其子元素的标签名即是各种命令，可以使用Ant的内建命令，也可以自己自定义，其中的属性相当于命令行中的参数，如mkdir ${dist}/lib。其中depends=则是依赖关系的体现，如果依赖命令还未执行，会先执行依赖命令。 下面是使用结果： 123456789101112131415unddd@unddd-virtual-machine:~/helloWorld$ ant runBuildfile: /home/unddd/helloWorld/build.xmlinit:compile: [javac] /home/unddd/helloWorld/build.xml:16: warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds [javac] Compiling 2 source files to /home/unddd/helloWorld/buildrun: [java] Done!!!BUILD SUCCESSFULTotal time: 0 secondsunddd@unddd-virtual-machine:~/helloWorld$ ant的简单使用不难，但是要深入学习还需要下功夫才行。 JunitJunit是一款Java的单元测试框架。在我看来，它通过测试类来测试目的方法是否能正常执行其功能。 简单使用junit通过注解和断言来进行测试，只要写一个测试类，并通过importJuint的api即可测试，下面是一个简单的测试类： 12345678910111213141516171819package com.vegchic.test;import junit.framework.TestCase;import org.junit.Test;import static org.junit.Assert.assertEquals;import com.vegchic.junittest.HelloWorld;public class HelloWorldTest &#123; @Test public void testSayHello() &#123; String res = HelloWorld.sayHello(); //should return \"Hello world\" assertEquals(res, \"Hello world\"); &#125; @Test public void testGetInt() &#123; int res = HelloWorld.getInt(); //should return 5; assertEquals(5, res); &#125;&#125; 然后输入java org.junit.runner.JunitCore &lt;testClassName&gt;即可运行测试。下面会介绍如何与ant搭配使用。 注解需要引入org.junit.*（Junit5中为org.junit.jupiter.api.*）。 @Test，即实际的测试方法。 @Before，在每个测试方法执行前执行。在Junit5中改为@BeforeEach。 @After，在每个测试方法后执行。在Junit5中改为@AfterEach。 @BeforeClass，静态测试方法，会在所有测试方法开始前测试，且只有一次。在Junit5中改为@BeforeAll。 @AfterClass，类似@BeforeClass。在Junit5中改为@AfterAll。 @Ignore，加了这个注解的@Test不会执行。在Junit5中改为@Disabled。 断言断言在org.junit.Assert.*中，为静态方法。junit5为org.junit.jupiter.Assertions。 方法 作用 void assertEquals(boolean expected, boolean actual) 检查两个变量或者等式是否相等 void assertArrayEquals​(boolean[] expected, boolean[] actual) 检查两个数组是否相等 void assertTrue​(boolean condition) 检查条件是真的 void assertNotNull(Object object) 检查对象不是空的 void assertSame​(java.lang.Object expected, java.lang.Object actual) 检查两个对象引用是否指向同一个对象 其中对于基本类型比较支持byte，char，float，boolean等类型（junit4中只支持Double），详情可见org.junit.Assert。 与Ant搭配使用前面说到，Ant支持测试，自然也为Junit提供了支持。下面是一个简单的test target。 1234567&lt;target name=\"test\" depends=\"compile\"&gt; &lt;junit&gt; &lt;classpath location=\"$&#123;build&#125;\"/&gt; &lt;formatter type=\"brief\" usefile=\"false\"/&gt; &lt;test name=\"$&#123;testClass&#125;\"/&gt; &lt;/junit&gt;&lt;/target&gt; &lt;classpath&gt;顾名思义，而&lt;formatter&gt;是测试的信息格式，&lt;test&gt;是测试类的名字。运行结果如下： 1234567891011121314151617unddd@unddd-virtual-machine:~/helloWorld$ ant testBuildfile: /home/unddd/helloWorld/build.xmlinit:compile: [javac] /home/unddd/helloWorld/build.xml:16: warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds [javac] Compiling 2 source files to /home/unddd/helloWorld/buildtest: [junit] Testsuite: com.vegchic.test.HelloWorldTest [junit] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.025 sec [junit] BUILD SUCCESSFULTotal time: 0 secondsunddd@unddd-virtual-machine:~/helloWorld$ Junit总结虽然看上去语法并不难而且也接触不到深入使用，但是我被它的配置和各种包弄得生不如死。但也让我对java的寻包有了更深的理解（只能这么安慰自己了）。","link":"/2018/04/25/Vi,Java, Ant,Junit自学报告/"},{"title":"【系分】第三周作业","text":"系统分析与设计第三周作业 简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点 从项目特点、风险特征、人力资源利用角度思考 瀑布模型瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。从本质来讲，它是一个软件开发架构，开发过程是通过一系列阶段顺序展开的，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈，因此，如果有信息未被覆盖或者发现了问题，那么最好 “返回”上一个阶段并进行适当的修改，开发进程从一个阶段“流动”到下一个阶段，这也是瀑布开发名称的由来。 优点 为项目提供了按阶段划分的检查点。 当前一阶段完成后，您只需要去关注后续阶段。 可在迭代模型中应用瀑布模型。 它在软件工程中占有重要地位，它提供了软件开发的基本框架，这比依靠“个人技艺”开发软件好得多。 它有利于大型软件开发过程中人员的组织、管理，有利于软件开发方法和工具的研究与使用，从而提高了大型软件项目开发的质量和效率。 缺点 在项目各个阶段之间极少有反馈。 只有在项目生命周期的后期才能看到结果。 通过过多的强制完成日期和里程碑来跟踪各个项目阶段。 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重后果。 增量模型增量模型融合了瀑布模型的基本成分（重复应用）和原型实现的迭代特征，该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。当使用增量模型时，第1个增量往往是核心的产品，即第1个增量实现了基本的需求，但很多补充的特征还没有发布。客户对每一个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。增量模型强调每一个增量均发布一个可操作的产品。 优点采用增量模型的优点是人员分配灵活，刚开始不用投入大量人力资源。如果核心产品很受欢迎，则可增加人力实现下一个增量。当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径。这样即可先发布部分功能给客户，对客户起到镇静剂的作用。此外，增量能够有计划地管理技术风险。 缺点 由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。 在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。 如果增量包之间存在相交的情况且未很好处理，则必须做全盘系统分析，这种模型将功能细化后分别开发的方法较适应于需求经常改变的软件开发过程。 螺旋模型螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。 优点 通过原型的建立，使软件开发在每个迭代的最初明确方向。 通过风险分析，最大程度地降低软件彻底失败造成损失的可能性。 在每个迭代阶段植入软件测试，使每个阶段的质量得到保证。 整体过程具备很高的灵活性，在开发过程的任何阶段自由应对变化。 每个迭代阶段累计开发成本，使支出状况容易掌握。 通过对用户反馈的采集，与用户沟通，以保证用户需求的最大实现。 缺点 过分依赖风险分析经验与技术，一旦在风险分析过程中出现偏差将造成重大损失； 过于灵活的开发过程不利于已经签署合同的客户与开发者之间的协调； 由于只适用大型软件，过大的风险管理支出会影响客户的最终收益； 简述统一过程三大特点，与面向对象的方法有什么关系？ 用例驱动（用例驱动开发过程） 用例是能够向用户提供有价值结果的系统中的一种功能，通过建立用例模型确定需求。基于用例模型，开发人员可以创建一系列实现这些用例的设计和实现模型。开发人员还可以审查每个后续建立的模型是否与用例模型一致。测试人员测试实现以确保实现模型的构件正确实现了用例。（用例被确定，用例被设计，用例被测试） 以架构为中心 软件架构是从不同的角度描述了即将构建的系统，他包含了系统的静态和动态特征。用例和架构是相互影响的。用例在实现时必须适合于架构，而架构必须预留空间以实现现有的或将来所有需要的用例。（架构的步骤：首先，从与用例无关的架构开始，创建一个粗略的架构轮廓。其次，处理已经确定的重要的用例子集，即主要的系统功能。最后，随着用例描述趋于完善，完善架构，直到得到一个稳定的架构。） 迭代和增量的 迭代是指工作流中的步骤，增量是指产品中增加的部分。迭代过程必须是受控的（好处：控制成本，降低风险，控制进度，精化完善需求）。 统一过程是一个面向对象的软件开发方法，它给出了有关软件开发过程组织及实施的指导。 简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？RUP中的软件生命周期在时间上被分解为四个顺序的阶段，分别是：初始阶段（Inception）、细化阶段（Elaboration）、构造阶段（Construction）和交付阶段（Transition）。每个阶段结束于一个主要的里程碑（Major Milestones）；每个阶段本质上是两个里程碑之间的时间跨度。在每个阶段的结尾执行一次评估以确定这个阶段的目标是否已经满足。如果评估结果令人满意的话，可以允许项目进入下一个阶段。 构思阶段：开发一个系统大致版本、构思业务例子、定义范围、粗略估计开发费用和计划。关键里程碑：生命周期目标（Lifecycle Objective）里程碑。生命周期目标里程碑评价项目基本的生存能力。 细化阶段：完成一个构建阶段的准确可靠的计划，并定位重要的风险因子。关键里程碑：生命周期结构（Lifecycle Architecture）里程碑。生命周期结构里程碑为系统的结构建立了管理基准并使项目小组能够在构建阶段中进行衡量。 构建阶段：完成一个待(在移交阶段)部署的软件。关键里程碑：初始功能（Initial Operational）里程碑。初始功能里程碑决定了产品是否可以在测试环境中进行部署。 移交阶段：部署给目标用户。关键里程碑：产品发布（Product Release）里程碑。此时，要确定目标是否实现，是否应该开始另一个开发周期。 软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？UP为企业按固定节奏生产、固定周期发布软件产品提供了依据。 UP将阶段划分为4个阶段：构想阶段、细化阶段、构造阶段、移交阶段，通过阶段划分，可以使企业能有一个固定的节奏来生产；UP的迭代性，使得项目组能周期性地产出交付物，因此固定周期地发布软件产品也是UP的指导。 带来的好处： 在软件开发的早期就可以对关键的、影响大的风险进行处理。 可以提出一个软件体系结构来指导开发。 可以更好的处理不可避免的需求变更。 可以较早的得到一个可运行的系统，鼓舞开发团队的士气，增强项目成功的信心。 为开发人员提供一个能更有效工作的开发过程。","link":"/2019/04/12/【系分】第三周作业/"},{"title":"【系分】第六周作业","text":"系统分析与设计第六周作业 简答题 用例的概念 用例是指一组用户使用一个系统实现一个目标的成功或失败的场景。是一种通过用户的使用场景来获取需求的技术。 用例和场景的关系？什么是主场景或 happy path？ 用例和场景的关系： 每一个用例包括了许多个场景，场景中包含了用户是如何与系统进行交互，即谁可以利用系统做什么事情。 主场景： 每一个用例中都包含一个主场景，主场景对应于系统主要的交互，通常是指成功的场景。 happy path: 在测试用例时没有出现预期之外结果的场景。在用例建模中，happy path 是主执行者完成了目标，所有有关人员的需求都得到了满足。 用例有哪些形式？ Brief (high level)：一段总结，通常是主要的成功场景的建立，只需要几分钟的时间 Casual（简便格式）：不是很正式的形式，并且包括了不同的场景 Fully：完整的场景建立，完整的步骤以及用例的细节，以及一些可能发生的情况的应对以及如何确保一个成功的场景 对于复杂业务，为什么编制完整用例非常难？ 对于复杂的业务来说，参与者（actor）的相对较多，系统交互也会非常复杂，需要考虑的备选流（alternate scenarios）也非常复杂，这将会是一个非常庞大，场景（scenario）众多的用例，因此对于这样的业务，我们要编制一个完整的用例是非常困难的，因为我们很难做到完整的覆盖所有可能的场景 什么是用例图？ 用例图主要用来描述 用户、需求、系统功能单元之间的关系。它展示了一个外部用户能够观察到的系统功能模型图。 用途：帮助开发团队以一种可视化的方式理解系统的功能需求。 用例图的基本符号与元素？ 参与者(Actor) 表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。 用例(Use Case) 用例就是外部可见的系统功能，对系统提供的服务进行描述。 用椭圆表示 子系统(Subsystem) 用来展示系统的一部分功能，这部分功能联系紧密。 关系 用例图中涉及的关系有：关联、泛化、包含、扩展； 如下表所示： 关联(Association) 表示参与者与用例之间的通信，任何一方都可发送或接受消息。 【箭头指向】：指向消息接收方 泛化(Inheritance) 就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。 【箭头指向】：指向父用例 包含(Include) 包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤； 【箭头指向】：指向分解出来的功能用例 扩展(Extend) 扩展关系是指 用例功能的延伸，相当于为基础用例提供一个附加功能。 【箭头指向】：指向基础用例 依赖(Dependency) 以上4中关系，是UML定义的标准关系。 但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示表示源用例依赖于目标用例； 【箭头指向】：指向被依赖项 项目(Artifact) 用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，VS2010中引入了“项目”这样一个元素，以便让开发人员能够在用例图中链接一个普通文档。 用依赖关系把某个用例依赖到项目上 然后把项目-》属性 的Hyperlink 设置到你的文档上，这样当你在用例图上 双击项目时，就会打开相关联的文档。 注释(Comment) 包含(include)、扩展(extend)、泛化(Inheritance) 的区别： 条件性：泛化中的子用例和 include 中的被包含的用例会无条件发生，而 extend 中的延伸用例的发生是有条件的； 直接性：泛化中的子用例和 extend 中的延伸用例为参与者提供直接服务，而 include 中被包含的用例为参与者提供间接服务。 对 extend 而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。 对 Inheritance 而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系； 用例图的画法与步骤 系统框放在中间，系统名写在上方正中间。 确定参与者，包括: 主要参与者：谁将使用系统的主要功能、谁将需要系统的支持以完成工作等 协作参与者：谁将提供对应的系统功能、谁将维护系统，保证系统处于工作状态等 幕后参与者：谁会对系统产生的结果感兴趣 确定参与者之间的关系（是否为泛化关系） 根据需求识别和创作用例。 确认用例间的关系，包括包含和扩展。 确认用例与参与者之间的关系，包括包含。 在用例的事件流中逐渐发现其他的支持系统，放置在系统框的右边。 用例图给利益相关人与开发者的价值有哪些？ 对于利益相关人来说： 可以直观看到系统的结果和用户的功能体验，保证系统按照用户的需求进行设计。 用例能够根据需要对复杂程度和形式化程序进行增减调节，即能够响应用户（利益相关人)提出的需求，而用例图则使得这种调节更加便利，可以通过修改图形间的关系实现。 对于开发者来说： 用例图是设计者设计过程的结论与参考，设计者与开发者之间的交流工具，开发者开发过程的蓝图。 用例图使得开发者能够更明确地获得需求，更好地理解需求。 用例图可以指导开发和测试，同时可以在整个过程中对其他工作流起到指导作用。 建模练习题（用例模型）选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求： 请使用用户的视角，描述用户目标或系统提供的服务 粒度达到子用例级别，并用 include 和 exclude 关联它们 请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例 尽可能识别外部系统和服务 为什么相似系统的用例图是相似的？ 相似系统面对的参与者和用例是相似的，用例之间的关系也是同构的。用户预期的功能都是相似的，即不同的同类系统一定具有一致基本功能以及带有自己特色的扩展功能。所以体现在用例图上也是相似的。 如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术 不同时代对预定的酒店的需求不同。可以让筛选算法与时俱进，满足一些不同的主流要求。且用户会需要更加优秀、好用、有参考价值的评价系统，也需要随时更新。而不同地区的消费特点不同，旅游胜地和普通城市用户对于酒店预订的需求有差别，可以在用例图上突出一些特点。 如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用 通过判断创新点在用例图中的位置。如果创新点属于直接与用户关联的用例，则在系统中的作用很重要。如果是子用例，则看与父用例的关系，如果是包含关系，则作用较大，如果是扩展用例，则作用较小。 请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表 ID Name Imp Est How to demo Notes 1 酒店查询 50 10 通过 GPS 或者用户自行选择位置，利用地图或者列表信息进行一定范围内酒店信息查询 通过 GPS API 进行用户位置的定位 2 酒店选择 20 2 用户可以利用酒店的房间数、房间大小、酒店评价等信息进行酒店的选定 需要注意酒店信息的实时更新，特别是房间数量的实时更新 3 房间预定 80 5 选定酒店后需要进行房间的预定，用户输入入住者的身份证号码、是否需要保险、手机号码等必要信息后创建订单 需要进行用户身份信息的核验，避免通过虚假信息预定房间 4 订单管理 30 10 用户在创建订单后可以对订单信息进行修改，比如取消订单，修改入住天数以及添加备注等 特价房间不能取消订单，只能提示用户通过保险公司理赔 5 费用支付 60 8 用户进行订单费用的支付 可以通过微信、支付宝、银联进行订单支付 6 账户管理 40 4 用户进行头像、昵称、身份信息、预留手机等个人信息的修改 需要核验昵称或图片是否含有非法信息 根据任务4，参考 使用用例点估算软件成本，给出项目用例点的估算 根据用户点方法，对用例分配权重的标准是： 简单用例：1 到 3 个事务，权重=5 一般用例：4 到 7 个事务，权重=10 复杂用例：多于 7 个事务，权重=15 用例 事务 计算 原因 UC权重 酒店查询 3 3 利用已知的酒店信息进行排序，或者用户输入关键词进行模糊查询 简单 酒店选择 6 5 提供酒店客房数量、客房类型、是否含有早餐等信息，需要及时更新客房信息 平均 房间预定 3 2 进行用户信息录入，创建订单 简单 订单管理 5 3 用户修改订单信息或取消订单 简单 费用支付 1 1 用户支付订单费用，调用API即可 简单 账户管理 4 1 用户修改个人信息 简单","link":"/2019/05/15/【系分】第六周作业的/"},{"title":"堆，二项队列，堆排序","text":"前言从堆到二项队列到堆排序….当然都只是简单的堆。 二叉堆(Binary Heap)堆也称优先队列，堆中的每个元素都有自己的权重，出堆操作会将 权重最小(或者最大) 的元素弹出。 二叉堆使用树来实现，树的根即堆顶，对于树的每一个节点，父亲的权重必然小于儿子的权重。下图即为一个堆(别问我为什么这么丑。。 但实际上并不需要使用树来储存，可以用数组来实现，故而上图中实际上为(别问丑。。 从上往下从左往右顺序存储在数组中。这种存储方式的性质为：heap[i]的儿子为heap[2*i]和heap[2*i+1](i从1开始，且儿子存在)，称为堆序性(heap order) push插入一个元素时，首先会找到数组的下一个空闲位置，将新元素放进去。然后，为了保持堆序性，将这个元素沿着其到根的路上滤(percolate up)，具体来说，便是swap(parent, child)，直到该位置能保持堆序性(此时元素的两个儿子都大于它)。 pop弹出一个元素时，由于根即是最小元，所以弹出它。但是为了填充这个空穴，需要将它下滤(percolate down)，具体来说，便是将最后一个元素heap[size]放进这个空穴中(为什么不是size-1见下文)，然后swap(blank, less)，将空穴blank与其儿子中的较小者less交换，直到空穴的儿子都比它大。 实现为了方便，将一个哑元(该哑元小于任何元素)放入heap[0]中，这样上滤一个最小元时便能因为heap[1]&gt;heap[1/2]而停止上滤。故而堆的下标应该从1开始。 具体源码不再放出，具体见vegchic/learn-ds/heap.cpp，其中main()为测试函数 二项队列(Binary Queue)普通二叉堆有一个弊端，合并困难(代价大)，故而需要更好的结构构建堆，书中讲述了左堆，斜堆，二项队列，这里实现了第三个(为啥不写左堆和斜堆呢，因为我忙(lan)啊 二项队列同样用树实现，但不同的是，它是树的集合，森林(forest)。里面的每一棵树也并非普通二叉树，而是二项树(binary tree)。在二项队列中，每一棵树的高度都不一样，高度为$k$的二项树由两棵高度为$k-1$的树合并而来，高度为$0$的树是一棵单节点树。 图即为$B_0, B_1, B_2, B_3$ 实现时对每个节点结构，应有两个指针，一个指向儿子，一个指向兄弟。 容易看出，任意的$N$都可以用2的幂相加得到(可看作二进制数)，所以二项队列可以表示任意堆。 push由于二项队列核心是合并(Merge)，所以插入可以看做是size=1的二项队列与被插入队列合并。 pop弹出时，应该遍历每一棵树的根，找出最小元所在的树(与二叉堆一样，每一棵树的最小元依然是根)，然后去掉该最小元，它的儿子便可以分成若干树，再将这些树合成一个新的二项队列，与原队列合并即可。 Merge两个二项队列的合并操作归根到底是合并两棵相同高度的树，知道队列中不存在相同高度的树即可，这就好像二进制数的加法一样，每一位不是1就是0，如果两个1相加，就要往前面进位。所以在实现时也体现了进位的思想。 而相同高度的树合并，为了使根依然为最小元，所以将根小的作为母树，根大的作为子树附上去(这棵子树是根的第一个儿子，所以要把原先的儿子的地址添加到该子树的根的兄弟指针上) 类实现在合并中，!!T1是当T1不为空时值为1，为空时值为0的表达式（可以说又让我这个菜鸡大开眼界了。另外，宏定义中MIN实际上是int类型的最大值，不过因为是用在找最小元上，所以就这样取名了(其实是因为MAX已经被占了，懒得改了 src123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#define MAX (32)#define MIN (~0 ^ (1 &lt;&lt; 31))class binaryQueue &#123; private: struct node &#123; int ele; node *sibling; node *child; node(int i, node* s = 0, node* c = 0): ele(i), sibling(s), child(c) &#123;&#125; ~node() &#123; if (sibling) delete sibling; if (child) delete child; &#125; &#125;; int _size; node* roots[MAX]; node* mergeSame(node *left, node *right) &#123; if (right -&gt; ele &lt; left -&gt; ele) return mergeSame(right, left); right -&gt; sibling = left -&gt; child; left -&gt; child = right; return left; &#125; public: binaryQueue(): _size(0) &#123; memset(roots, 0, MAX * sizeof(binaryQueue*)); &#125; ~binaryQueue() &#123; clear(); &#125; binaryQueue&amp; push(int e) &#123; node *newNode = new node(e); binaryQueue temp; temp.roots[0] = newNode; ++temp._size; merge(temp); return *this; &#125; binaryQueue&amp; merge(binaryQueue &amp;heap) &#123; if (heap._size + this -&gt; _size &gt; MIN) &#123; cout &lt;&lt; \"Error!\"; return *this; &#125; node *T1(0), *T2(0), *carry(0); int i(0), j(1); _size += heap._size; for ( ; j &lt;= _size; j *= 2, ++i) &#123; T1 = roots[i], T2 = heap.roots[i]; switch(!!T1 + !!T2 * 2 + !!carry * 4) &#123; case 0: //no trees case 1: //only T1 break; case 2: //only T2 roots[i] = T2; heap.roots[i] = 0; break; case 3: //T1 and T2 carry = mergeSame(T1, T2); roots[i] = 0; heap.roots[i] = 0; break; case 4: //only carry roots[i] = carry; carry = 0; break; case 5: //T1 and carry carry = mergeSame(T1, carry); roots[i] = 0; break; case 6: //T2 and carry carry = mergeSame(T2, carry); heap.roots[i] = 0; break; case 7: //all roots[i] = carry; carry = mergeSame(T1, T2); heap.roots[i] = 0; break; &#125; &#125; return *this; &#125; int pop() &#123; if (_size == 0) return -1; int index = 0, min = MIN; for (int i = 0, j = 1; j &lt;= _size; ++i, j *= 2) if (roots[i] &amp;&amp; roots[i] -&gt; ele &lt; min) &#123; index = i; min = roots[i] -&gt; ele; &#125; node *deletedNode = roots[index]; node *children = roots[index] -&gt; child; roots[index] -&gt; child = 0; delete roots[index]; roots[index] = 0; binaryQueue deletedHeap; deletedHeap._size = (1 &lt;&lt; index) - 1; for (int i = index - 1; i &gt;= 0; --i) &#123; deletedHeap.roots[i] = children; children = children -&gt; sibling; deletedHeap.roots[i] -&gt; sibling = 0; &#125; roots[index] = 0; _size -= (deletedHeap._size + 1); merge(deletedHeap); return min; &#125; int size() &#123; return _size; &#125; void clear() &#123; for (int i = 0, j = 1; j &lt;= _size; j *= 2, ++i) &#123; if (roots[i]) delete roots[i]; &#125; &#125; int top() &#123; if (_size == 0) return -1; int index = 0, min = MIN; for (int i = 0, j = 1; j &lt;= _size; ++i, j *= 2) if (roots[i] &amp;&amp; roots[i] -&gt; ele &lt; min) &#123; index = i; min = roots[i] -&gt; ele; &#125; return min; &#125;&#125;; 测试自己测了一下，貌似没问题，然后就去leetcode随便找了道题做了下 leetcode23 时间有点慢。。因为要测试Merge()所以没想太多直接写了(说得好像想了就能快一样。顺便贴下Solution123456789101112131415161718192021222324class Solution &#123; public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; binaryQueue h; for (int i = 0; i &lt; lists.size(); ++i) &#123; binaryQueue tempHeap; ListNode* temp = lists[i]; while (temp) &#123; tempHeap.push(temp -&gt; val); temp = temp -&gt; next; &#125; h.merge(tempHeap); &#125; if (h.size() == 0) return 0; ListNode* res = new ListNode(h.pop()); ListNode* temp = res; while (h.size() != 0) &#123; temp -&gt; next = new ListNode(h.pop()); temp = temp -&gt; next; &#125; return res; &#125;&#125;; 堆排序($O(N\\log N)$)因为堆的特殊性质，便可以将之用于排序，对N个元素首先构建堆然后进行N次pop()操作。也可以用于解决选择问题（找出第几大的数。 如果使用一个额外的数组存储pop()的返回值，虽然不会显著增加运行时间，但会增加额外空间消耗。 因为每次pop()都会使数组$size-1$，所以可以将返回值放在堆尾，如果使用普通堆，得到的将是递减的数组，所以这里使用 (max)堆 (即每次都会弹出最大元) src1234567891011121314151617181920212223242526272829303132#define leftChild(i) ((i) * 2 + 1)class heapSort &#123; private: void down(vector&lt;int&gt; &amp;arr, int index, int size) &#123; int ele = arr[index], child(0); for ( ; leftChild(index) &lt; size; index = child) &#123; child = leftChild(index); if (child + 1 &lt; size &amp;&amp; arr[child] &lt; arr[child + 1]) ++child; if (arr[child] &gt; ele) arr[index] = arr[child]; else break; &#125; arr[child] = ele; &#125; public: vector&lt;int&gt;&amp; sort(vector&lt;int&gt; &amp;arr) &#123; if (arr.size() == 0) return arr; int size = arr.size(); for (int index = size / 2; index &gt;= 0; --index) down(arr, index, size); for (int index = size - 1; index &gt; 0; --index) &#123; int temp = arr[0]; arr[0] = arr[index]; arr[index] = temp; down(arr, 0, index); &#125; return arr; &#125;&#125;; Reference雷打不动的《数据结构》以及Dadio","link":"/2017/11/19/堆，二项队列，堆排序/"},{"title":"AVL树简介及C++实现","text":"AVL树简介AVL树是一棵自平衡的二叉查找树，由G.M. Adelson-Velsky和E.M. Landis在他们1962 年的论文《An algorithm for the organization of information》中发表。 什么是自平衡普通的二叉查找树虽然遍历简单，但是存在一个问题：树的结构容易变坏。比如，当插入序列为[1, 2, 3, 4]时，普通的二叉查找树便会退化为普通链表；又比如，当对一棵完全二叉查找树进行多次删除时，不管是使用前驱删除（即用被删节点的前驱节点替代该位置）或后继删除（用后继节点替代），都会使树偏向某一边。此时，为了解决这个问题，AVL树使用了旋转方法实现自平衡。 这是一棵典型的“坏树” 这是一棵“好树” 平衡条件高度（height）高度为每个节点都具有的属性，其值为该节点左右孩子的高度的最大值 + 1，而空节点的高度在这里定义为-1。由此推出，叶子节点高度为0。 何时需要调整当一个节点左右儿子的高度差大于等于（实际上等于即可）2时，则判定该节点不平衡，并对其进行旋转。 上图中’23’节点左儿子的高度为-1，而右儿子的高度为1，相差为2，故不平衡。 旋转旋转，个人认为形容很贴切的一个词，当插入（删除）结束后，跳出递归时便要对各节点（也就是被操作节点到根的路径上的节点）进行判断是否平衡，当不平衡时，便以该节点为目标进行旋转，旋转会return一个node*，以将新的子树传递回去。 考虑这样一颗初始树： 根据插入节点高度的不同，可以分为四种情况： LeftLeft当插入一个值为’1’的节点时树将变得不再平衡，’8’的左儿子高度为2，右儿子的高度为0。 因为节点是其父亲的左儿子，其父亲又是上一节点的左儿子，故而称为Leftleft的情况以方便记忆，此时的旋转为左单旋转（只旋转一次） 可以形象的理解为图中三个节点顺时针转了一圈，’8’转了之后变成了’4’的右儿子，所以原先的右儿子便要“换爸爸”，变成’8’的左儿子，这就完成了旋转。 RightRight如果理解了leftleft，那rightright也不难理解，只是情况变成了节点是父亲的右儿子，父亲又是上一节点的右儿子。现在对树插入’35’ 可见’29’的左右儿子高度差为2，需要右单旋转。 此时，’29’变为’32’的新左儿子（因为没有原左儿子，故较为易懂，但实现上还是需要一视同仁） 以上便是旋转的基本操作，而接下来的两种情况只是以上两种单旋转的复合罢了。 LeftRightleftright意为节点为其父亲的右儿子，但是其父亲为其上一节点的左儿子，此时不管是左单旋转还是右单旋转，都不能使树平衡（可以自己尝试验证），所以要对树进行两次旋转。首先对上面的树插入’25’，插入后平衡故不需旋转。但是此时插入’27’，则树会变成下图的不平衡状态 既然这不是熟知的情况，那就先将其变成熟知的情况。下面的节点’25’进行一次右旋转 现在就可以对’29’进行熟悉的左旋转了 这样便可以得到一棵新的平衡树了。 RightLeft对新的平衡树插入’61’，此时树处于平衡，然后插入’55’ 现在即使rightleft情况，被插入节点是其父亲的左儿子，其父亲是上一节点的右儿子。类似leftright，可以先进行一次左旋转，使其变为熟知的rightright 现在再进行一次右旋转 这样便可以实现rightleft的平衡了。 对谁进行旋转就插入而言，下面几种情况都是对被插入节点而言，但如果是删除的话，就不存在这种节点了，那么删除又是对谁而言呢？就个人的理解，旋转的真正情况分类应对不平衡的节点而言，即leftleft是指不平衡节点的左儿子高度比右儿子大，而左儿子的左儿子也比左儿子的右儿子高度大，简单来说，引起不平衡的节点在左儿子的左子树上（可能有点绕，可以结合图理解）。类似地，rightright是因为不平衡节点在右儿子的右子树上，以此类推leftright和rightleft。这样子理解更容易看懂下面的删除如何选择旋转。 类的设计节点是用名为node的struct保存，里面除了其元素和左右孩子指针，还有一个额外的高度。AVL树是名为avl的class，提供插入删除，以及前中后序的遍历，private成员有四种旋转方法，并有一个height(node*)返回节点高度，避免了多余的节点是否为空的讨论。因为使用的递归插入和删除需要传递节点，故真正的插入删除放在了private中，而用户只需使用insert(int)和remove(int)即可。 插入在这里使用的是递归插入，在插入后判断是否平衡，并更新高度。 删除在这里使用了后继删除，并用引用传入节点，减少了将父节点更新的麻烦，也避免了内存泄漏。删除分为三种情况： 被删除节点有右儿子也有右儿子，则将其右子树上的最小节点替代被删除节点的位置。也就是说，如果右儿子有左儿子，则一直顺着左儿子遍历下去，直到找到“最左”的儿子；如果右儿子没有左儿子，则直接用右儿子代替被删除节点的位置。 例如图中要删除根节点’41’的话，将’49’代替掉’41’。 被删除节点只有一个儿子，则直接让该儿子代替被删除节点的位置。例如，同样是上面的树，如果要删除’20’的话，用’29’代替 被删除节点为叶子节点，直接删除。 第一种情况换个思路可以看成删除需要替代被删除节点的节点，然后把这个节点的值赋给被删除节点，这样便变相的“删除”了目标。这样想的好处是第一种情况又可以调用自身去删除替代节点而不用去考虑高度的更新和重新平衡子树。而最终都可以达到第三种或者第二情况从而停止递归。（至于是否需要多余的时间代价我没有去仔细想） Test前期：利用gdb与https://visualgo.net/en进行逐步对比，用时最长但也是能找出bug的笨方法后期：虽然说后期其实也就用时1个早上而已，自己写了个随机数插入并删除，并在删除后用队列BFS检查节点，然后手动运行n次，至于内存检查使用valgrind src123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#include &lt;iostream&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define TEST_SIZE 1000using namespace std;struct node &#123; int ele; node *left; node *right; int height; node(int i, node *l, node *r, int h): ele(i), left(l), right(r), height(h) &#123;&#125;&#125;;class avl &#123; private: node *root; node* leftleft(node *T) &#123; node *temp = T -&gt; left; T -&gt; left = temp -&gt; right; temp -&gt; right = T; T -&gt; height = ((height(T -&gt; left) &gt; height(T -&gt; right)) ? height(T -&gt; left) : height(T -&gt; right)) + 1; temp -&gt; height = ((T -&gt; height &gt; height(temp -&gt; left)) ? T -&gt; height : height(temp -&gt; left)) + 1; return temp; &#125; node* rightright(node *T) &#123; node *temp = T -&gt; right; T -&gt; right = temp -&gt; left; temp -&gt; left = T; T -&gt; height = ((height(T -&gt; left) &gt; height(T -&gt; right)) ? height(T -&gt; left) : height(T -&gt; right)) + 1; temp -&gt; height = ((T -&gt; height &gt; height(temp -&gt; right)) ? T -&gt; height : height(temp -&gt; right)) + 1; return temp; &#125; node* leftright(node *T) &#123; T -&gt; left = rightright(T -&gt; left); return leftleft(T); &#125; node* rightleft(node *T) &#123; T -&gt; right = leftleft(T -&gt; right); return rightright(T); &#125; int height(node* t) &#123; if (t == 0) return -1; else return t -&gt; height; &#125; node* realInsert(int i, node *T) &#123; if (T == 0) &#123; T = new node(i, 0, 0, 0); &#125; else if (i &lt; T -&gt; ele) &#123; T -&gt; left = realInsert(i, T -&gt; left); if (height(T -&gt; left) - height(T -&gt; right) == 2) if (i &lt; T -&gt; left -&gt; ele) T = leftleft(T); else T = leftright(T); &#125; else if (i &gt; T -&gt; ele) &#123; T -&gt; right = realInsert(i, T -&gt; right); if (height(T -&gt; right) - height(T -&gt; left) == 2) if (i &gt; T -&gt; right-&gt; ele) T = rightright(T); else T = rightleft(T); &#125; T -&gt; height = ((height(T -&gt; left) &gt; height(T -&gt; right)) ? height(T -&gt; left) : height(T -&gt; right)) + 1; return T; &#125; bool realRemove(node *&amp;T, int i) &#123; if (!T) return false; if (i &lt; T -&gt; ele) &#123; if (realRemove(T -&gt; left, i) == false) &#123; return false; &#125; else if (height(T -&gt; right) - height(T -&gt; left) == 2) &#123; if (height(T -&gt; right -&gt; left) &lt;= height(T -&gt; right -&gt; right)) T = rightright(T); else T = rightleft(T); &#125; else &#123; T -&gt; height = ((height(T -&gt; left) &gt; height(T -&gt; right)) ? height(T -&gt; left) : height(T -&gt; right)) + 1; &#125; &#125; else if (i &gt; T -&gt; ele) &#123; if (realRemove(T -&gt; right, i) == false) &#123; return false; &#125; else if (height(T -&gt; left) - height(T -&gt; right) == 2) &#123; if (height(T -&gt; left -&gt; right) &lt;= height(T -&gt; left -&gt; left)) T = leftleft(T); else T = leftright(T); &#125; else &#123; T -&gt; height = ((height(T -&gt; left) &gt; height(T -&gt; right)) ? height(T -&gt; left) : height(T -&gt; right)) + 1; &#125; &#125; else &#123; if (T -&gt; right &amp;&amp; T -&gt; left) &#123; node *temp = T -&gt; right; if (temp -&gt; left) &#123; while (temp -&gt; left &amp;&amp; temp -&gt; left -&gt; left) &#123; temp = temp -&gt; left; &#125; int key = temp -&gt; left -&gt; ele; node *oldT = T; realRemove(T, key); oldT -&gt; ele = key; &#125; else &#123; int key = temp -&gt; ele; node *oldT = T; realRemove(T, key); oldT -&gt; ele = key; &#125; &#125; else if (T -&gt; left || T -&gt; right) &#123; node *temp = (T -&gt; left) ? T -&gt; left : T -&gt; right; delete T; T = temp; &#125; else &#123; delete T; T = 0; &#125; &#125; return true; &#125; public: avl(): root(0) &#123;&#125; ~avl() &#123; clear(); root = 0; &#125; void preorder(void(*fun)(node*), node* T) &#123; if (T == 0) return; fun(T); preorder(fun, T -&gt; left); preorder(fun, T -&gt; right); &#125; void postorder(void(*fun)(node*), node* T) &#123; if (T == 0) return; postorder(fun, T -&gt; left); postorder(fun, T -&gt; right); fun(T); &#125; void inorder(void(*fun)(node*), node* T) &#123; if (T == 0) return; inorder(fun, T -&gt; left); fun(T); inorder(fun, T -&gt; right); &#125; void clear() &#123; postorder([](node *t) -&gt; void &#123;delete t;&#125;, root); &#125; void insert(int i) &#123; root = realInsert(i, root); &#125; bool remove(int i) &#123; if (!root) return false; return realRemove(root, i); &#125; //测试函数 void printPreorder() &#123; preorder([](node *t) -&gt; void &#123;cout &lt;&lt; t -&gt; ele &lt;&lt; \" \";&#125;, root); &#125; void printInorder() &#123; inorder([](node *t) -&gt; void &#123;cout &lt;&lt; t -&gt; ele &lt;&lt; \" \";&#125;, root); &#125; bool check() &#123; queue&lt;node*&gt; bfs; if (root == 0) return true; bfs.push(root); while (bfs.size()) &#123; node* t = bfs.front(); bfs.pop(); if ((height(t -&gt; left) - height(t -&gt; right) &gt;= 2) || (height(t -&gt; left) - height(t -&gt; right) &lt;= -2)) return false; if ((height(t) != height(t -&gt; left) + 1) &amp;&amp; (height(t) != height(t -&gt; right) + 1)) return false; if ((t -&gt; left &amp;&amp; (t -&gt; ele &lt; t -&gt; left -&gt; ele)) || (t -&gt; right &amp;&amp; (t -&gt; ele &gt; t -&gt; right -&gt; ele))) return false; if (t -&gt; left) bfs.push(t -&gt; left); if (t -&gt; right) bfs.push(t -&gt; right); &#125; return true; &#125; bool isRemoved(int i, vector&lt;int&gt; nodes) &#123; node *temp = root; if (root == 0) return true; for (int index = 0; index &lt; nodes.size(); ++index) &#123; while (temp &amp;&amp; temp -&gt; ele != nodes[index]) &#123; if (nodes[index] &lt; temp -&gt; ele) temp = temp -&gt; left; else temp = temp -&gt; right; &#125; if ((temp &amp;&amp; temp -&gt; ele == i) || (temp == 0 &amp;&amp; nodes[index] != i)) return false; temp = root; &#125; return true; &#125;&#125;;bool test() &#123; int count = 0; avl test; default_random_engine e(time(0)); uniform_int_distribution&lt;unsigned&gt; u(0,TEST_SIZE); vector&lt;int&gt; ran; for (int i = 0; i &lt; TEST_SIZE; ++i) &#123; int num = u(e); test.insert(num); if (find(ran.begin(), ran.end(), num) == ran.end()) ran.push_back(num); if (test.check() == false) return false; &#125; test.printPreorder(); cout &lt;&lt; endl; test.printInorder(); cout &lt;&lt; '\\n' &lt;&lt; ran.size() &lt;&lt; endl; e.seed(time(0) + 1); while (ran.size() != 0) &#123; uniform_int_distribution&lt;unsigned&gt; u1(0,ran.size() - 1); int index = u1(e); if (test.remove(ran[index])) ++count; if (test.check() == false || test.isRemoved(ran[index], ran) == false) return false; ran.erase(ran.begin() + index); &#125; test.printInorder(); cout &lt;&lt; endl; test.printPreorder(); cout &lt;&lt; '\\n' &lt;&lt; count &lt;&lt; endl; return true;&#125;int main() &#123; cout &lt;&lt; test() &lt;&lt; endl; return 0;&#125; 结语 其实插入操作很早就写好了（因为书上已经有实现代码了，但是删除操作是最近才写好的，大概经历了不知道怎么删除-&gt;删除之后怎么更新高度和重新平衡-&gt;debug的阶段，也复习了下二叉树的删除操作。 不得不说好的函数名是多么重要，刚开始我为旋转的命名是按照书上的命名（如singleRotateWithLeft())，时常要重看代码区分哪个是哪个，后来改叫leftleft()后简单易懂，悔不当初啊 自己写的test代码也是bug多多，没测出树的bug倒是debug了挺久的test代码。 本来对双旋转也理解的不是很深，在写这篇博客时突然想到可以理解为化简为单旋转的情况。 因为偷懒所以把实现都写到了类里，其实应该把类的定义写在.h文件里，把方法实现写在单独的.cpp里。 最后照例贴Reference，AVL树是学习《数据结构与算法分析——C语言描述》,Mark Allen Weiss的，图是从https://visualgo.net/en截图的，然后自己加上了辣眼睛的箭头，另外，二叉树删除的操作参考了jarun/dslib/","link":"/2017/10/26/AVL树简介及C++实现/"},{"title":"【系分】第一周作业","text":"系统分析与设计第一周作业 软件工程的定义 软件工程学科诞生后，人们为软件工程给出了不同的定义，例如最早的定义是由 F.L. Bauer 给出的，即”软件工程是为了经济地获得能够在实际机器上高效运行的、可靠的软件而建立和应用一系列坚实的软件工程原则”。而美国梅隆卡耐基大学软件工程研究所（SEI）给出的定义则是软件工程是以工程的形式应用计算机科学和数学原理，从而经济有效地解决软件问题。但目前普遍使用的软件工程定义是由 IEEE 给出的，即软件工程是将系统性的、规范化的、可定量的方法应用于软件的开发、运行和维护。 软件工程概念实际存在两层含义，从狭义概念看，软件工程着重体现在软件过程中所采用的工程方法和管理体系，例如，引入成本核算、质量管理和项目管理等，即将软件产品开发看作是一项工程项目所需要的系统工程学和管理学。从广义概念看，软件工程涵盖了软件生命周期中所有的工程方法、技术和工具，包括需求工程、设计、编程、测试和维护的全部内容，即完成一个软件产品所必备的思想、理论、方法、技术和工具。 解释导致 software crisis 本质原因、表现，述说克服软件危机的方法 原因： 软件的规模越来越大，结构越来越复杂。 软件开发管理困难而复杂。 软件开发费用不断增加。 软件开发技术落后。 生产方式落后。 开发工具落后，生产率提高缓慢。 表现： 经费预算经常突破，完成时间一再拖延。由于缺乏软件开发的经验和软件开发数据的积累，使得开发工作的计划很难制定。主观盲目制定计划，执行起来与实际情况有很大差距，使得开发经费一再突破。由于对工作量估计不足，对开发难度估计不足，进度计划无法按时完成，开发时间一再拖延。 开发的软件不能满足用户要求。开发初期对用户的要求了解不够明确，未能得到明确的表达。开发工作开始后，软件人员和用户又未能及时交换意见，使得一些问题不能及时解决，导致开发的软件不能满足用户的要求，因而导致开发失败。 开发的软件可维护性差。开发过程中没有同意的、公认的规范，软件开发人员按各自的风格工作，各行其是，开发过程无完整、规范的文档，发现问题后进行杂乱无章的修改。程序结构不好，运行时发现错误也很难修改，导致维护性差。 开发的软件可靠性差。由于在开发过程中，没有确保软件质量的体系和措施，在软件测试时，又没有严格的、充分的、完全的测试，提交给用户的软件质量差，在运行中暴露出大量的问题。 克服： 为了消除软件危机，首先应该对计算机软件有一个正确的认识。正如上面所说，应该彻底消除在计算机系统早期发展阶段形成的“软件就是程序”的错误观念。一个软件必须由一个完整的配置组成，事实上，软件是程序、数据及相关文档的完整集合。其中，程序是能够完成预定功能和性能的可执行的指令序列；数据是使程序能够适当的处理信息的数据结构；文档是开发、使用和维护所需要的图文资料。 更重要的是，必须充分认识到软件开发不是某个个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合共同完成的工程项目。必须充分吸收和借鉴人类长期以来从事各种工作项目所积累的行之有效的原理、概念、技术和方法。特别要吸收几十年来人类从事计算机硬件研究和开发的经验教训。 应该推广使用在实践总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法，尽快消除在计算机系统早期发展阶段形成的错误观念和做法。 应该开发和使用更好的软件工具。正如机械工具可以“放大”人类体力一样，软件工具可以“放大”人类的智力。在软件开发的每个阶段都有许多烦琐重复的工作需要完成，在适当的软件工具辅助下，开发人员可以把这类工作做得既快又好。如果把各个阶段使用的软件工具有机的集合成一个整体，支持软件开发的全过程，则称为软件工程支撑环境。 软件生命周期 六大阶段： 可行性分析和计划阶段 确定软件开发的总体目标，给出功能，性能，可靠性，接口等方面的要求，进行可行性分析 估计可利用的资源(硬件，软件，人力等)，成本，效益，开发进度，进行投资收益分析，制定开发计划 提交可行性分析报告，开发计划等文档 需求分析阶段 分析用户提出的要求，给出需求详细定义，确定软件系统的各项功能，性能需求和设计约束，确定对文档的编制的要求 提交软件需求说明，软件规格说明，数据要求说明等文档和初步用户手册 设计阶段 概要设计：将各项需求转换为软件的体系结构。软件的每一组成部分都是意义明确的模块，每个模块和某些需求相对应 详细设计：对没一个模块要完成的工作进行具体的描述，提供源编程编写的直接依据 提交结构设计说明，详细设计说明和测试计划初稿等文稿 实现阶段 实现源码编码，编译，和排错调试，得到没有语法错误的程序清单。程序结构良好，清晰易读，且与设计想一致 编写进度日报，周报，和月报 提交用户手册，操作手册等面向用户的文档的编写工作 编写测试计划 测试阶段 全面测试目标软件系统，并检查审阅已编制的文档，提交测试分析报告。逐项评价所生产的程序、文档以及开发工作本身，提交项目开发总结报告 在整个开发过程中 (即前五个阶段中)，开发集体需要按月编写开发进度月报。 运行与维护阶段 软件提交给用户后，在运行使用中得到持续维护，根据用户新提出的需求进行必要而且可能的扩充、删改、更新和升级。 软件维护包括改正性维护 (发现错误)、适应性维护 (适应运行环境变化) 和完善性维护 (增强功能)。 常见模型： 瀑布模型 (Waterfall Model) V-W 模型 (V Model and W Model) 快速应用开发模型 (RAD Model) 原型模型 (Prototype Model) 增量/演化/迭代模型 (Incremental Model) 螺旋模型 (Spiral Model) 喷泉模型 (Fountain Model, Object-Oriented Model) 基于构件的开发模型 (CBSD Model) Rational 统一过程模型 (RUP Model) *敏捷开发模型与极限编程 (Agile Modeling and XP) SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide 请中文翻译其名称与简短说明） 软件需求：软件要求 KA 关注软件需求的启发，协商，分析，规范和验证。在软件行业中，人们普遍认为，当这些活动表现不佳时，软件工程项目非常容易受到攻击。软件需求表达了对软件产品的需求和限制，这些需求和约束有助于解决一些现实问题。 软件设计：设计被定义为定义系统或组件的体系结构，组件，接口和其他特征的过程以及[该]过程的结果（IEEE 1991）。软件设计 KA 涵盖了设计过程和最终产品。软件设计过程是软件工程生命周期活动，其中分析软件需求以产生软件内部结构及其行为的描述，将作为其构造的基础。软件设计（结果）必须描述软件体系结构——即软件如何分解和组织成组件以及这些组件之间的接口。它还必须描述能够构建它们的详细程度的组件。 软件构建：软件构建是指通过结合详细设计，编码，单元测试，集成测试，调试和验证来创建工作软件的细节。软件构建 KA 包括与满足其要求和设计约束的软件程序开发相关的主题。该 KA 涵盖了软件构建基础;管理软件建设；建筑技术；实际考虑；和软件构建工具。 软件测试：测试是一项旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。这些测试用例是从（通常非常大的）执行域中选择的。软件测试 KA 包括软件测试的基础知识；测试技术；人机界面测试与评估；与测试有关的措施；和实际考虑。 软件维护：软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。这些类别称为完善，自适应和纠正性软件维护。软件维护 KA 包括软件维护的基础知识（维护的性质和需求，维护类别，维护成本）；软件维护中的关键问题（技术问题，管理问题，维护成本估算，软件维护测量）；维护过程;软件维护技术（程序理解，重新设计，逆向工程，重构，软件退役）；灾难恢复技术和软件维护工具。 软件配置管理：系统的配置是硬件，固件，软件或这些的组合的功能和/或物理特征。它还可以被视为根据特定构建过程组合的特定版本的硬件，固件或软件项的集合，以满足特定目的。因此，软件配置管理（SCM）是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。软件配置管理 KA 涵盖 SCM 过程的管理；软件配置识别，控制，状态核算，审计；软件发布管理和交付；和软件配置管理工具。 软件工程管理：软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。软件工程管理 KA 涵盖了启动和范围定义（确定和协商要求，可行性分析以及要求的审查和修订）；软件项目计划（过程计划，工作量估算，成本和进度，资源分配，风险分析，质量计划）；软件项目制定（计量，报告和控制;收购和供应商合同管理）；产品验收；审查和分析项目绩效；项目结束；和软件管理工具。 软件工程过程：软件工程 KA 关注软件生命周期过程的定义，实施，评估，测量，管理和改进。涵盖的主题包括流程实施和变更（流程基础架构，流程实施和变更模型以及软件流程管理）；流程定义（软件生命周期模型和流程，流程定义，流程适应和流程自动化的符号）；过程评估模型和方法；测量（过程测量，产品测量，测量技术和测量结果的质量）；和软件处理工具。 软件工程模型和方法：软件工程模型和方法 KA 解决了涵盖多个生命周期阶段的方法;其他KAs涵盖特定生命周期阶段的特定方法。涵盖的主题包括建模（软件工程模型的原理和属性;语法与语义与不变量；前置条件，后置条件和不变量）；模型类型（信息，结构和行为模型）；分析（分析正确性，完整性，一致性，质量和相互作用；可追溯性；以及权衡分析）；和软件开发方法（启发式方法，形式方法，原型方法和敏捷方法）。 软件质量：软件质量是许多 SWEBOK V3 KAs 中普遍存在的软件生命周期问题。此外，软件质量 KA 还包括软件质量的基础知识（软件工程文化，软件质量特性，软件质量的价值和成本以及软件质量改进）；软件质量管理流程（软件质量保证，验证和确认，审核和审核）；和实际考虑（缺陷表征，软件质量测量和软件质量工具）。 软件工程专业实践：软件工程专业实践关注软件工程师必须具备的专业，负责和道德的软件工程知识，技能和态度。软件工程专业实践 KA 涵盖专业性（专业行为，专业协会，软件工程标准，雇佣合同和法律问题）；道德准则;小组动态（团队合作，认知问题复杂性，与利益相关者互动，处理不确定性和模糊性，处理多元文化环境）；和沟通技巧。 软件工程经济学：软件工程经济学 KA 关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。涵盖的主题包括软件工程经济学的基本原理（提案，现金流量，货币时间价值，计划视野，通货膨胀，折旧，替代和退休决策）；非营利性决策（成本效益分析，优化分析）；估计，经济风险和不确定性（估算技术，风险决策和不确定性）；和多属性决策（价值和衡量尺度，补偿和非补偿技术）。 计算基础：计算基础 KA 涵盖了提供软件工程实践所需的计算背景的基础主题。涵盖的主题包括问题解决技术，抽象，算法和复杂性，编程基础，并行和分布式计算的基础知识，计算机组织，操作系统和网络通信。 数学基础：数学基础 KA 涵盖了提供软件工程实践所必需的数学背景的基础主题。涵盖的主题包括集合，关系和功能；基本命题和谓词逻辑；证明技术；图形和树；离散概率；语法和有限状态机；和数论。 工程基础：工程基础 KA 涵盖了提供软件工程实践所必需的工程背景的基础主题。涵盖的主题包括经验方法和实验技术；统计分析；测量和指标；工程设计；仿真与建模；和根本原因分析。 简单解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。 初始级 软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。 可管理级 建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。 已定义级 已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。 量化管理级 分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。 优化管理级 过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。 每个等级都被分解为过程域，特殊目标和特殊实践，通用目标、通用实践和共同特性： 每个等级都有几个过程区域组成，这几个过程域共同形成一种软件过程能力。每个过程域，都有一些特殊目标和通用目标，通过相应的特殊实践和通用实践来实现这些目标。当一个过程域的所有特殊实践和通用实践都按要求得到实施，就能实现该过程域的目标。 用自己语言简述 SWEBok 或 CMMI （约200字） CMMI 全称是 Capability Maturity Model Integration，即能力成熟度模型集成（ 也有称为：软件能力成熟度集成模型）。 定义：对于软件组织在定义、实现、度量、控制和 改善其软件过程的各个发展阶段的描述。 目的：帮助企业进行对软件工程过程的管理和改进 , 增强开发制造能力 , 从而能按时地、不超预算地制造质量的软件。 通俗一点说，CMMI就是一套指南，做事的一般方法，改进质量的参考框架。我们参考它提供的方法，通过控制我们的项目管理过程，来达到提高软件质量的目的。 CMMI为企业带来价值主要体现在以下几个方面： 对开发流程进行标准化和规范化，保证项目进度和质量。 有利于成本控制，缩减不必要的项目开支。 建立完备的知识库，不畏惧人才流失。 持续改善流程，提高质量和效率。 在一些投标项目竞争中，更具有优势。——这也是一般外包公司特别重视这个证的原因。 来自美国制定的国际标准，更能得到国外的认可。——所以一般软件公司要准备融资上市前都力争拿到此证的原因。","link":"/2019/03/08/【系分】第一周作业/"},{"title":"操作系统的一些算法","text":"复（yu）习操作系统时做的一些笔记 调度算法 FCFS（先到先服务） SJF（最短作业优先） 优先级调度 RR（轮转法） 多级队列 多级反馈队列 临界区问题 Peterson算法 TestAndSet 信号量（semaphore） 经典同步问题 死锁 资源分配图 资源分配图算法 银行家算法 死锁检测 内存 动态存储分配问题 分页 分段 段页式（Segmentation with Paging） 虚拟内存 按需调页 页置换算法 帧分配 文件系统 目录结构 分层文件系统 VFS 目录实现 分配方法 空闲空间管理 磁盘调度 FCFS SSTF SCAN C-SCAN LOOK/C-LOOK RAID I/O 子系统 缓冲 高速缓存 假脱机 调度算法平均等待时间 FCFS（先到先服务）非抢占的，先请求CPU 的进程先分配到 CPU。FCFS 策略可以用 FIFO 队列来容易地实现。当一个进程进入到就绪队列，其PCB 链接到队列的尾部。当 CPU 空闲时，CPU 分配给位于队列头的进程，接着该运行进程从队列中删除。 SJF（最短作业优先）优先级调度的一个特例，每个进程与其下一个 CPU 区间段相关联。当 CPU 为空闲 时，它会赋给具有最短 CPU 区间的进程。如果两个进程具有同样长度，那么可以使用 FCFS 调度来处理。 平均等待时间最小（最佳），通过将短进程移到长进程之前，短进程等待时间的减少大于长进程等待时间的增加。 困难：如何知道下一个CPU 区间的长度。 近似：根据上一次实际区间长度和预测长度进行指数平均 $\\tau _{n+1} = at_n + (1-a)\\tau_n (0 \\le a \\le 1)$，$a=1$ 时，取决于实际上次实际长度，$a=0$ 时，只与上次预测有关。$a$ 一般为 $1/2$。 抢占 SJF 算法可抢占当前运行的进程，而非抢占 SJF 算法会允许当前运行的进程先完成其 CPU 区间。 抢占 SJF 调度有时称为最短剩余时间优先调度(SRTF，Shortest-Remaining-Time-First scheduling) 优先级调度每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到 CPU。具有相同优先级的进程按 FCFS 顺序调度。（书上优先级越低，优先程度越高） 当一个进程到达就绪队列时，其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。 问题：无穷阻塞(indefinite blocking) 或饥饿 (starvation)。可以运行但缺乏 CPU 的进程可认为是阻塞的，它在等待 CPU 。优先级调度算法会使某个低优先级进程无穷等待 CPU。结果：1. 最终能运行。2. 系统最终崩溃并失去所有未完成的低优先级进程。 解决：老化（aging），逐渐增加在系统中等待很长时间的进程的优先级。 RR（轮转法）round-robin算法，抢占的，专门为分时系统设计。类似 FCFS，但增加了抢占以切换进程。定义一个较小时间单元，称为时间片（time quan or time slice） 。时间片通常为10~100 ms 。将就绪队列作为循环队列。 CPU 调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU。 实现：将就绪队列保存为进程的 FIFO 队列。新进程增加到就绪队列的尾部。 CPU 调度程序从就绪队列中选择第一个进程，设置定时器在一个时间片之后中断，再分派该进程。 在极端情况下，如果时间片非常大， 那么 RR 算法与 FCFS 算法一样。如果时间片很小（如 1ms），那么 RR 算法称为处理器共享，（从理论上来说）$n$ 个进程对于用户都有它自己的处理器，速度为真正处理器速度的 $1/n$，实际上因为有上下文切换所以不能太小。 会有上下文切换的额外开销。绝大多数现代操作系统的时间分配为10 ~100ms ，上下文切换的时间一般少于 10μs。 根据经验， 应该有 80% 的 CPU 区间小于时间片。 周转时间也依赖于时间片的大小，通常，如果绝大多数进程能在一个时间片内完成，那么平均周转时间会改善。 多级队列多级队列调度算法 （multilevel queue scheduling algorithm） 将就绪队列分成多个独立队列。根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被永久地分配到一个队列（优点是低调度开销，缺点是不够灵活）。每个队列有自己的调度算法。 队列之间必须有调度，通常采用固定优先级抢占调度，可能会有饥饿。 队列之间划分时间片。每个队列都有一定的 CPU 时间，这可用于调度队列内的进程 。 多级反馈队列多级反馈队调度算法 (multilevel feedback queue scheduling algorithm) ，根据不同 CPU 区间的特点以区分进程。如果进程使用过多 CPU 时间，那么它会被转移到更低优先级队列。这种方案将I/O型和交互进程留在更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。 规定优先程度越低则时间片越长（减少CPU型的调度次数）。如果进程因请求I/O，让出了CPU，那么在I/O完成后，进程将进入优先级比I/O请求时离开的队列高(一级)的队列中。 优先程度高的抢占优先程度低的进程。 多级反馈队列调度程序的定义使它成为最通用的 CPU 调度算法。它可被配置以适应特定系统设计。不幸的是，由于需要一些方法来选择参数以定义最佳的调度程序，它也是最复杂的算法。 临界区问题Peterson算法由于现代计算机体系架构执行基本机器语言指令，如load， store 的不同方式，在某些机器上不一定能正确运行。需要假设load，store是原子操作。 12345678910do &#123; flag[i] = TRUE; turn = j; /* 最后执行，最后进入 */ while (flag[j] &amp;&amp; turn == j); // critical section flag[i] = FALSE; // reminder section&#125; while (TRUE); turn 表示哪个进程可以进入临界期，flag 表示哪个进程准备进入临界区。 TestAndSet1234567891011121314151617181920lock = FALSE;waiting[n] = &#123; FALSE &#125;;do &#123; waiting[i] = TRUE; key = TRUE; while (waiting[i] &amp;&amp; key) key = TestAndSet(&amp;lock); waiting[i] = FALSE; // critical section j = (i + 1) % n; while ((j != i) &amp;&amp; !waiting[j]) j = (j + 1) % n; if (j == i) lock = FALSE; else waiting[j] = FALSE; // reminder section&#125; while (TRUE); 信号量（semaphore）互斥： 12345678semaphore mutex = 1;do &#123; wait(mutex); // critical section signal(mutex); // reminder section&#125; while (TRUE) 同步： 1semaphore mutex = 1; 12// S1signal(mutex); 12wait(mutex);// S2 经典同步问题有限缓冲问题empty表示空缓冲项，full表示满缓冲项 123// sharesemaphore mutex = 1;int empty = n, full = 0; 12345678910111213// producerdo &#123; ... // produce an item ... wait(empty); wait(mutex); ... // add item ... signal(mutex); signal(full);&#125; while (TRUE); 12345678910// consumerdo &#123; wait(full); wait(mutex); ... // remove an item ... signal(mutex); signal(empty);&#125; while (TRUE); 读者-写者问题读者优先： 123// sharesemaphore mutex = 1, wrt = 1;int readcount = 0; 12345678// writerdo &#123; wait(wrt); ... // writing ... signal(wrt);&#125; while (TRUE); 12345678910111213141516// readerdo &#123; wait(mutex); ++readcount; if (readcount == 1) wait(wrt); signal(mutex); ... // reading ... wait(mutex); --readcount; if (readcount == 0) signal(wrt); signal(mutex);&#125; while (TRUE); 写者优先： 123// shareint readcount = 0, writecount = 0;semaphore rmutex = 1, wmutex = 1, readTry = 1, resource = 1; 123456789101112131415161718// writerdo &#123; wait(wmutex); ++writecount; if (writecount == 1) wait(readTry); signal(wmutex); wait(resource); // writing signal(resource); wait(wmutex); --writecount; if (writecount == 0) signal(readTry); signal(wmutex);&#125; while (TRUE); 1234567891011121314151617do &#123; wait(readTry); wait(rmutex); ++readcount; if (readcount == 1) wait(resource); signal(rmutex); signal(readTry); // reading wait(rmutex); --readcount; if (readcount == 0) signal(resource); signal(rmutex);&#125; while (TRUE); 平等： 123// shareint readcount = 0;semaphore resource = 1, readCountAccess = 1, serviceQueue = 1; 12345678// writerdo &#123; wait(serviceQueue); wait(resource); signal(serviceQueue); // writing signal(resource);&#125; while (TRUE); 12345678910111213141516// readerdo &#123; wait(serviceQueue); wait(readCountAccess); if (readcount == 0) wait(resource); ++readcount; signal(serviceQueue); signal(readCountAccess); // reading wait(readCountAccess); --readCount; if (readCount == 0) signal(resource); signal(readcountAccess);&#125; while (TRUE); 哲学家就餐问题无法解决饿死问题。 方案1：先拿编号小的筷子 12345678910do &#123; int m = min(i, (i + 1) % 5); int n = max(i, (i + 1) % 5); wait(chopstick[m]); wait(chopstick[n]); // eat signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); // think&#125; while (TRUE) 方案2：最多只允许4个哲学家同时坐在桌子上。 方案3：只有当两根筷子都空闲时才允许拿起。 理发师问题123// sharesemaphore barberReady = 0, accessWRSeats = 1, custReady = 0;int WRSeets = N; 123456789// barberdo &#123; wait(custReady); wait(accessWRSeets); ++WRSeets; signal(barberReady); signal(accessWRSeets); // cut hair&#125; while (TRUE); 123456789101112// customerwait(accessWRSeets);if (WRSeets &gt; 0) &#123; --WRSeets; signal(custReady); signal(accessWRSeets); wait(barberReady); // have hair cut&#125; else &#123; signal(accessWRSeets); // leave&#125; 死锁资源分配图每种资源都只有单个实例时，有环是充分必要条件；多个实例时，有环是必要条件。 资源分配图算法适用于每种资源只有单个实例 资源分配图：在资源分配图中加入需求边，以虚线表示。系统必须事先说明所要求的资源，即当进程 $P_i$ 开始执行时，所有需求边必须先处于资源分配图。可放宽这个条件，以允许只有在进程 $P_i$ 的所有相关的边都为需求边时才将需求边 $P_i \\to R_j$ 增加到图中。 内容：假设进程 $P_i$ 申请资源 $R_j$。只有在将申请边 $P_i$ 变成分配边 $P_i$ 而不会导致资源分配图形成环时，才允许申请。 代价为$O(n^2)$。 银行家算法 Available：长度为 $m$ 的向量，表示每种资源的现有实例的数量。如果 $Available[j]=k$ ，那么资源$R_j$现有 $k$ 个实例。 Max：$n \\times m$ 矩阵，定义每个进程的最大需求。如果 $Max[i][j]=k$，那么进程 $P_i$最多可以申请 $k$ 个资源类型 $R_j$ 的实例。 Allocation：$n \\times m$ 矩阵，定义每个进程现在所分配的各种资源类型的实例数量。如果 $Allocation[i][j]=k$，那么进程 $P_i$ 现在已分配了 $k$ 个资源类型 $R_j$ 的实例。 Need：$n \\times m$ 矩阵，表示每个进程还需要的剩余的资源。如果 $Need[i][j] = k$，那么进程 $P_i$ 还可能申请 $k$ 个资源类型 $R_j$ 的实例。注意，$Need[i][j] = Max[i][j] - Allocation[i][j]$。 $Allocation_i$ 表示分配给 $P_i$ 的资源；$Need_i$ 表示进程为完成其任务可能需要申请的额外资源。 向量 $X \\le Y$ 当且仅当 $X[i] \\le Y[i]$。 安全性算法确定系统是否处于安全状态。 设 $Work$ 和 $Finish$ 分别为长度为 $m$ 和 $n$ 的向量。按如下方式进行初始化，$Work=Available$ 且 $\\text{for}\\ i=0,1,\\ldots ,n-1,Finish[i]=false$。 查找这样的 $i$ 满足使其满足 $Finish[i]=false$ $Need_i \\le Work$ 如果没有这样的 $i$ 存在，那么就转到第4步。 $Work = Work + Allocation_i$，$Finish[i]=true$，返回到第2步 如果对所有 $i$，$Finish[i]=true$，那么系统处于安全状态。 代价：$O(m \\times n^2)$ 资源请求算法判断是否可安全允许请求。 设 $Request_i$ 为进程 $P_i$ 的请求向量。如果 $Request_i[j] == k$，那么进程 $P_i$ 需要资源类型 $R_j$ 的实例数量为 $k$。当进程 $P_i$ 作出资源请求时，采取如下动作。 如果 $Request_i \\le Need_i$，那么转到第2步，否则产生出错条件，因为进程 $P_i$ 已超过了其最大请求。 如果 $Request_i \\le Available$，那么转到第3步，否则，$P_i$ 必须等待，因为没有可用资源。 假定系统可以分配给进程 $P_i$ 所请求的资源，并按如下方式修改状态： $ Available=Available-Request_i$ $Allocation_i=Allocation_i+Request_i$ $Need_i=Need_i-Request_i$ 如果所产生的资源分配状态是安全的，那么交易完成且进程 $P_i$ 可分配到其所需要资源。然而，如果新状态不安全，那么进程 $P_i$ 必须等待 $Request_i$ 并恢复到原来资源分配状态。 死锁检测单实例等待（wait-for）图：等待图有一条 $P_i \\to P_j$的边，当且仅当相应的资源分配图中包含两条边 $P_i \\to R_q$ 和 $R_q \\to P_j$，其中 $R_q$ 为资源。 当且仅当有环时死锁，$O(n^2)$ 多实例 Available：长度为 $m$ 的向量，表示每种资源的现有实例的数量。如果 $Available[j]=k$ ，那么资源$R_j$现有 $k$ 个实例。 Allocation：$n \\times m$ 矩阵，定义每个进程现在所分配的各种资源类型的实例数量。如果 $Allocation[i][j]=k$，那么进程 $P_i$ 现在已分配了 $k$ 个资源类型 $R_j$ 的实例。 Request：$n \\times m$ 矩阵，表示当前每个进程的资源请求情况。如果 $Request[i][j] = k$，那么进程 $P_i$ 现在正在请求 $k$ 个资源类型 $R_j$ 的实例。 设 $Work$ 和 $Finish$ 分别为长度为 $m$ 和 $n$ 的向量。初始化 $Work=Available$。对 $i = 0,1,\\ldots,n-1$，如果 $Allocation_i$不为0，则$Finish[i]=false$，否则为 $true$ 找到满足下面条件的 $i$： $Finish[i]=false$ $Request_i\\le Work$ 如果没有这样的 $i$，则转到第4步。 $Work=Work+Allocation_i$，$Finish[i]=true$，转到第2步 如果对某个 $i(0 \\le i \\lt n)$，$Finish[i]=false$，则系统处于死锁状态，而且，如果$Finish[i]=false$，则进程 $P_i$ 死锁。 代价：$O(m \\times n^2)$ 内存动态存储分配问题 首次适应：分配第一小足够大的孔。查找可以从头开始，也可以从上次首次适应结束时开始。一旦找到足够大的空闲孔，就可以停止。 最佳适应：分配最小的足够大的孔。必须查找整个列表，除非列表按大小排序。这种方法可以产生最小剩余孔。 最差适应：分配最大的孔。同样，必须查找整个列表，除非列表按大小排序。这种方法可以产生最大剩余孔，该孔可能比最佳适应方法产生的较小剩余孔更为有用。 比较：首次适应和最佳适应在执行时间和利用空间方面都好于最差适应；首次适应和最佳适应在利用空间方面难分伯仲，但是首次适应方法更快些。 最佳适应和首次适应都存在外碎片问题。 50%规则：对采用首次适应方法的统计说明，不管使用什么优化，假定有 $N$ 个可分配块，那么可能有 $0.5N$ 个块为外部碎片。即 $1/3$ 的内存可能不能使用。 分页页号 $\\to$ 页表 $\\to$ 帧号 存在内碎片但不存在外碎片。 TLB：$EAT=\\alpha(m+n)+(1-\\alpha)(2m+n)$，其中 $\\alpha$ 为命中率，$n$ 为快表访问时间，$m$为内存访问单位时间。 页表结构 层次页表（两（三…）级分页算法）：将页表再分页。向前映射页表（forward-mapped page table） 变种：VAX结构（分区） 哈希页表：每个元素有3个域：虚拟页码，所映射的帧号，指向链表下一个元素的指针。 算法：虚拟（逻辑）地址中的虚拟页号转换到哈希表中，用虚拟页号与链表中的每个元素的第一个域相比较。如果匹配，那么相应的帧号(第二个域)就用来形成物理地址；如果不匹配，那么就对链表中的下一个节点进行比较，以寻找一个匹配的页号。 变种：群集页表（clustered page table）每一条目不只包括一页信息，而是包括多页。 反向页表：对于每个真正的内存页或帧才有一个条目。整个系统只有一个页表，对每个物理内存的页只有一条相应的条目。 简化的反向页表实现：系统的每个虚拟地址有一个三元组 &lt;pid, page-number, offset&gt; 分段虚拟地址：&lt;segment-number, offset&gt; 段表：&lt;base, limit&gt;，STBR，STLR 重定位：动态重定位。 分享：分享段号。 申请空间：首次适应/最佳适应，会有外碎片。 段页式（Segmentation with Paging）MULTICS：段表保存页表基址（而不是段基址）。 Intel 386：分段 + 两级分页。 虚拟内存处理页错误陷阱： 检查进程的内部页表（通常与PCB 一起保存），以确定该引用是合法还是非法的地址访问。 如果引用非法，那么终止进程。如果引用有效但是尚未调入页面，那么现在应调入。 找到一个空闲帧（例如，从空闲帧链表中选取二个）。 调度一个磁盘操作，以便将所需要的页调入刚分配的帧。 当磁盘读操作完成后，修改进程的内部表和页表，以表示该页己在内存中。 重新开始因陷阱而中断的指令。进程现在能访问所需的页，就好像它似乎总在内存中。 按需调页$$EAT = (1 - p) \\times ma + p \\times (\\text{page fault overhead} + [\\text{ swap page out }] + \\text{swap page in} + \\text{restart overhead})$$ $p$ 为页错误概率，$ma$ 为内存访问时间（10 ~ 200ns）。换出不一定需要。 页置换算法FIFOFIFO 页置换算法为每个页记录着该页调入内存的时间。当必须置换一页时，将选择最旧的页。 Belady异常：页错误率可能会随着所分配的帧数的增加而增加。 最优置换最优页置换算法是所有算法中产生页错误率最低的，且绝没有 Belady异常 的问题。被称为 OPT 或 MIN。 它会置换最长时间不会使用的页（未来一段时间）。 难以实现，用于比较研究。 LRU最近最少使用算法。置换最长时间没有使用的页（过去一段时间）。 实现： 计数器：对每次内存引用，计数器都会增加。每次内存引用时，时钟寄存器的内容会被复制到相应页所对应页表工页的使用时间域内。置换时需要搜索。 栈：每当引用一个页，该页就从栈中删除并放在顶部。所以该栈可实现为具有头指针和尾指针的双向链表。这样，删除一页并放在栈顶部在最坏情况下需要改变6个指针。更新费时，但是置换时不需要搜索。 栈算法最优置换和 LRU置换 都没有 Be1ady异常。这两个都属于同一类算法，称为栈算法(stack algorithm) 。对于帧数为 $n$ 的内存页集合永远是对于帧数为 $n+1$ 的内存页集合的子集。对于LRU 算法，如果内存页的集合为最近引用的页，那么对于帧的增加，这 $n$ 页仍然为最近引用的页，所以也仍然在内存中。 需要有硬件的支持，否则时间开销会很大。 近似LRU页置换页表内的每项都关联着一个引用位（reference bit）。每当引用一个页时（无论是对页的字节进行读或写），相应页表的引用位就被硬件置位。 附加引用位算法在规定时间间隔里记录引用位。例如，如果移位寄存器含有00000000，那么该页在8个时间周期内没有使用；如果移位寄存器的值为11111111，那么该页在过去每个周期内都至少使用过一次。具有值为11000100的移位寄存器的页要比值为01110111的页更为最近使用。如果将这8位作为无符号整数，那么具有最小值的页为 LRU 页，且可以被置换。注意这些数字并不唯一，可以置换所有具有最小值的页，或在这些页之间采用 FIFO 来选择置换。 二次机会算法二次机会置换的基本算法是 FIFO 置换算法。当要选择一个页时，检查其引用位。如果其值为0，那么就直接置换该页。如果引用位为1，那么就给该页第二次机会，并选择下一个 FIFO 页。当一个页获得第二次机会时，其引用位清零，且其到达时间设为当前时间。 可以采用循环队列（也称时钟算法）。最坏时所有位均已置位，此时算法退化为 FIFO。 增强型二次机会算法对引用位和脏位同时考虑： $(0,0)$，最近没有使用也没有修改——用于置换的最佳页 $(0,1)$，最近没有使用但修改过——不是很好，因为在置换之前需要将页写出到磁盘。 $(1,0)$，最近使用过但没有修改一一它有可能很快又要被使用。 $(1,1)$，最近近使用过且修改过一一它有可能很快又要被使用，且置换之前需要将页写出到磁盘。 使用时钟算法时判断类型，替换第一个符合的（由上往下优先级越低）。 基于计数的页置换为每个页保留一个用于记录其引用次数的计数器。实现费时，且不能很好的近似OPT。 LFU最不经常使用页置换算法：置换计数最小的页。 问题：一个页在进程开始时使用很多，但以后就不再使用。由于其使用过很多，所以它有较大次数，所以即使不再使用仍然会在内存中。 解决：定期地将次数寄存器右移一位，以形成指数衰减的平均使用次数。 MFU最常使用页置换算法，基于如下理论：具有最小次数的页可能刚刚调进来，且还没有使用。 页缓冲算法系统通常保留一个空闲帧缓冲池。当出现页错误时，会像以前一样选择一个牺牲帧。然而，在牺牲帧写出之前，所需要的页就从缓冲地中读到空闲内存。这种方法允许进程尽可能快地重启，而无须等待牺牲帧页的写出。当在牺牲帧以后写出时，它再加入到空闲帧池。 扩展： 维护一个己修改页的列表。每当调页设备空闲时，就选择一个修改页井写到磁盘上，接着重新设置其修改位。这种方案增加了当需要选择置换时干净页的概率而不必写出。 保留一个空闲帧池，但要记住哪些页在哪些帧中。由于当帧写到磁盘上时其内容并没有修改，所以在该帧被重用之前如果需要使用原来页，那么原来页可直接从空闲帧池中取出来使用。这时并不需要 I/O 。当一个页错误发生时，先检查所需要页是否在空闲帧池中。如果不在，那么才必须选择一个空闲帧来读入所需页。 帧分配 平均分配 按比例分配 分配随着多道程序程度变化。如果考虑优先级，则按比例可以根据优先级大小分配，或进程大小和优先级的组合（此时称优先级分配，不考虑则称固定分配）。 全局置换，一个进程可以从另一个进程中拿到帧。 缺点：不能控制页错误率。 优点：更好的系统吞吐量。 局部置换，要求每个进程仅从其自己的分配帧中进行选择。 缺点：不能用其他进程的不常用的内存。 局部模型，如果分配的帧数少于现有局部的大小，那么进程会颠簸。 工作集合模型，防止了颠簸，并尽可能地提高了多道程序的程度。因此，它优化了 CPU 使用率。困难是难以追踪工作集合，可以通过固定定时中断和引用位近似模拟。 页错误频率（PPF），设置上限和下限。太高时分配帧；太低时移走帧。 文件系统目录结构 单层结构目录，命名困难，不能分组。 双层结构目录，允许不同目录有相同名字的文件，搜索更有效率，共享困难。 树状结构目录，允许分组，搜索更有效率。 无环图结构目录，允许分享。更灵活，但是删除需要谨慎处理。 通用图结构目录，同样有删除的问题。 分层文件系统 逻辑文件系统和文件组织模块为文件系统单独拥有，基本文件系统和 I/O 控制可以共用 VFS 对不同的文件类型分配一系列操作，调用相应的函数指针（指向函数表），从而不关心文件类型 索引节点对象（inode object）表示一个单独的文件对象。 文件对象（file object）表示一个打开的文件。 超级块对象（superlock object）表示整个文件系统。 目录条目对象（dentry object）表示一个单独的目录条目。 目录实现 线性表，简单但是费时。 哈希表，加快了搜索时间，简化了插入删除，但要解决冲突问题和固定大小问题。 分配方法连续分配要求每个文件在磁盘上占有一组连续的块。 用于访问连续分配文件所需要的寻道数最小，在确实需要寻道时所需要的寻道时间也最小。 问题：为新文件找到空间。 可以使用动态存储分配，首次适合和最优适合都要比最坏适合更为高效。首次适合和最优适合在空间使用方面不相上下，但是首次适合运行速度更快。但存在外碎片。可以试用合并，但是用时很长，在线合并会使性能明显下降。 问题：确定文件需要的空间大小。 可以终止用户程序，并加上合适的错误消息。用户必须分配更多空间并再次运行程序。这些重复运行可能代价很高。为了防止这些问题，用户通常会过多地估计所需的磁盘空间，从而导致了空间浪费。 找一个更大的孔，复制文件内容到新空间，释放以前的空间。只要空间存在这些动作就可以重复，不过这比较耗费时间。 会存在内碎片。 可以使用扩展，该方案开始分配一块连续空间，当空间不够时，另一块被称为扩展(extent)的连续空间会添加到原来的分配中。文件块的位置就成为开始地址、块数、加上一个指向下一扩展的指针。如果扩展太大，内部碎片可能仍然是个问题；随着不同大小的扩展的分配和删除，外部碎片可能也是个问题。 链接分配链接分配 （linked allocation） 解决了连续分配的所有问题。采用链接分配，每个文件是磁盘块的链表；磁盘块分布在磁盘的任何地方。目录包含文件第一块的指针和最后一块的指针。 没有外碎片。 缺点： 只能顺序访问。 指针需要空间。 解决方法：多个块组成簇，并按簇而不是按块来分配。减少指针个数。 可靠性，由于文件时通过指针链接的，而指针分布在整个磁盘上，如果指针丢失或损坏会导致链接空闲空间列表或另一个文件，一个不彻底的解决方案是使用双向链表或在每个块中存上文件名和相对块数。 变种使用文件分配表（FAT），每个卷的开始部分用于存储该 FAT 。每块都在该表中有一项，该表可以通过块号码来索引。 目录条目包含有文件首块的块号码。根据块号码索引的 FAT 条目包含文件下一块的块号码。这条链会一直继续到最后一块，该块对应 FAT 条目的值为文件结束值。 如果不对 FAT 采用缓存，FAT 分配方案可能导致大量的磁头寻道时间。磁头必须移到卷的开头以便读入 FAT，寻找所需要块的位置，接着移到块本身的位置。在最坏的情况下，每块都需要移动两次。其优点是改善了随机访问时间，因为通过读入 FAT 信息，磁头能找到任何块的位置。 索引分配索引分配 （indexed allocation） 通过把所有指针放在一起，即通过索引块解决了链接分配不能有效支持直接访问（没有FAT时）的问题。 优点：索引分配支持直接访问，且没有外部碎片问题，这是因为磁盘上的任一块都可满足更多空间的要求。 缺点：索引分配会浪费空间。索引块指针的开销通常要比链接分配指针的开销大。 索引的大小： 链接方案：二个索引块通常为一个磁盘块。因此，它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。 多层索引：链接表示的一种变种是用第一层索引块指向一组第二层的索引块，第二层索引块再指向文件块。 组合方案：参考 UFS 的 inode 索引分配方案与链接分配一样在性能方面有所欠缺。特别是，虽然索引块可以缓存在内存中，但是数据块可能分布在整个分区上。 空闲空间管理位图/位向量通常，空闲空间表实现为位图 （bit map）或位向量（bit vector）。每块用一位表示。如果一块为空闲，那么其位为 1；如果一块已分配，那么其位为 0。 计算：$(\\text{number of bits per word}) \\times (\\text{number of 0-value words})+\\text{offset of first 1 bit}$ 优点：查找磁盘上第一个空闲块和 $n$ 个连续空闲块时相对简单和高效。 缺点：除非整个位向量都能保存在内存中（井时而写入到磁盘用于恢复的需要），否则位向量的效率就不高（大磁盘不适宜） 链表将所有空闲磁盘块用链表连接起来，并将指向第一空闲块的指针保存在磁盘的特殊位置，同时也缓存在内存中。 遍历时效率不高，需要大量的 I/O。 FAT 方法将空闲块的计算结合到分配数据结构中，不再需要另外的方法。 组对空闲链表的一个改进是将 $n$ 个空闲块的地址存在第一个空闲块中。这些块中的前 $n-1$ 个确实为空，而最后一块包含另外 $n$ 个空闲块的地址，如此继续。 计数通常，有多个连续块需要同时分配或释放，尤其是在使用连续分配和采用簇时更是如此。因此，不是记录 $n$ 个空闲块的地址，而是可以记录第一块的地址和紧跟第一块的连续的空闲块的数量 $n$。这样，空闲空间表的每个条目包括磁盘地址和数量。虽然每个条目会比原来需要更多空间，但是表的总长度会更短，这是 因为连续块的数量常常大于 l 。 磁盘调度FCFS SSTF最短寻道时间优先算法（shortest-seek-time-first, SSTF），选择距当前磁头位置由最短寻道时间的请求来处理。类似于最短作业优先（SJF），可能导致“饥饿”。 SCAN也被称为电梯算法（elevator algorithm），磁臂从磁盘的一端向另一端移动，同时当磁头移过每个柱面时，处 理位于该柱面上的服务请求。当到达另一端时，磁头改变移动方向，处理继续。 C-SCANCircular SCAN，提供一个更为均匀的等待时间。与 SCAN 一样，C-SCAN 将磁头从磁盘一端移到磁盘的另一端，随着移动不断地处理请求。不过，当磁头移到另一端时，它会马上返回到磁盘开始，返回时并不处理请求。 LOOK/C-LOOK类似 SCAN/C-SCAN，但是磁头只移动到一个方向上最远的请求为止。它们在朝一个方向移动会看 （look） 是否有请求。 C-LOOK： RAID C：数据的第二副本，P：纠错位 RAID 0：按块级分散的磁盘阵列，没有冗余。 RAID 1：磁盘镜像。 RAID 2：也称内存方式的差错纠正代码结构，如果一个磁盘出错，那么可从其他磁盘中读取字节的其他位和相关差错纠正位，以重新构造被损坏的数据。注意，对于 4 个磁盘的数据， RAID 4级别只用了 3 个额外磁盘，而 RAID 1 级别则需要用 4 个额外磁盘。在实际中不使用 RAID 3：又称位交织奇偶结构，如果一个扇区损坏，那么知道是哪个扇区，通过计算其他磁盘 扇区相应位的奇偶值可得出所损坏位是 1 还是 0。 RAID 4：又称块交织奇偶结构，采用块级分散，另外在一独立磁盘上保存其他 $N$ 个磁盘相应块的奇偶块。 RAID 5：又称块交织分布奇偶结构，将数据和奇偶分布在所有 $N+l$ 块磁盘上。例如，对于 $5$ 个磁盘的阵列，第 $n$ 块的奇偶保存在磁盘 $(n\\ \\text{mod}\\ 5)+1$ 上。 RAID 6：也称为P+Q冗余方案，与 RAID 5相似，但是使用差错纠正码和Read-Solomon码。图中的方案为每 4 个位的数据使用了 2 个位的冗余数据，而不是像级别 5 那样的一个奇偶位，这样系统可以容忍两个磁盘出错。 RAID 0+1：RAID 0 提供了性能，而 RAID 1 提供了可靠性。一组磁盘被分散成条，每一条再镜像到另一条。 RAID 1+0：先镜像，再分条。 I/O 子系统I/O操作调度：设备状态表配备等待队列。 缓冲缓冲区是用来保存两个设备之间或在设备和应用程序之间所传输数据的内存区域。采用缓冲的三种理由： 处理数据流的生产者与消费者之间的速度差异。双缓冲将生产者与消费者进 行分离解楠，因而缓和两者之间的时序要求。 协调传输数据大小不一致的设备。缓冲常常用来处理消息的分段和重组。 支持应用程序 I/O 的复制语义。根据“复制语义”，操作系统保证要写入磁盘的数据就是 write()系统调用发生时的版本，而无须顾虑应用程序缓冲区随后发生的变化。一个简单方法就是操作系统在 write() 系统调用返回到应用程序之前将应用程序缓冲区复制到内核缓冲区中。 高速缓存高速缓存（cache） 是可以保留数据副本的高速存储器。高速缓冲区副本的访问要比原始数据访问要更为高效。 缓冲与高速缓存的差别是缓冲可能是数据项的唯一的副本，而根据定义高速缓存只是提供了一个驻留在其他地方的数据在高速存储 上的一个副本。 假脱机假脱机（Spooling）是用来保存设备输出的缓冲区，这些设备（如打印机）不能接收交叉的数据流。 用程序的输出先是假脱机到一个独立的磁盘文件上。当应用程序完成打印时，假脱机系统将对相应 的待送打印机的假脱机文件进行排队。假脱机系统一次复制一个己排队的假胁机文件到打印机上。","link":"/2018/07/19/OS算法/"}],"tags":[{"name":"homework","slug":"homework","link":"/tags/homework/"},{"name":"computer vision","slug":"computer-vision","link":"/tags/computer-vision/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"morphing","slug":"morphing","link":"/tags/morphing/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"canny","slug":"canny","link":"/tags/canny/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ant","slug":"ant","link":"/tags/ant/"},{"name":"junit","slug":"junit","link":"/tags/junit/"},{"name":"vi/vim","slug":"vi-vim","link":"/tags/vi-vim/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"ds","slug":"ds","link":"/tags/ds/"},{"name":"avl","slug":"avl","link":"/tags/avl/"},{"name":"OS","slug":"OS","link":"/tags/OS/"}],"categories":[{"name":"computer vision","slug":"computer-vision","link":"/categories/computer-vision/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"tech","slug":"tech","link":"/categories/tech/"},{"name":"LaTex","slug":"LaTex","link":"/categories/LaTex/"},{"name":"homework","slug":"homework","link":"/categories/homework/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"ds","slug":"ds","link":"/categories/ds/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"}]}